<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 7.0.0">

  

  

  
    <meta name="author" content="Blair Ren">
  

  

  

  <title>Android图形显示简述 | Renaissance</title>

  

  
    <link rel="shortcut icon" href="/Tom.ico">
  

  <!--mathjax latex数学公式显示支持-->
  
  

  

  

  
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(https://github.com/BlairRenaissance/ImageHost/blob/main/WechatIMG61.jpg?raw=true)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Renaissance
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">Home</a></li>
        
          <li class="navbar-list-item"><a href="/archives/">Archives</a></li>
        
          <li class="navbar-list-item"><a href="/category/">Categories</a></li>
        
          <li class="navbar-list-item"><a href="/tag/">Tags</a></li>
        
          <li class="navbar-list-item"><a href="/about">About</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">Android图形显示简述</h1>
          <h2 class="title-sub-wrap">
            <strong>Blair Ren</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2024-01-09T16:00:00.000Z" itemprop="datePublished">2024-01-10</time>
          </h2>
          
            <h2 class="last-time">
              <span>最后更新于</span>
              <time  class="article-updated" datetime="2024-02-01T06:55:34.370Z" itemprop="dateUpdated">2024-02-01</time>
            </h2>
          
          
          <ul class="wrap-list dark">
  
    <li><a href="/category/Android/">📒 Android</a></li>
  
</ul>
          <ul class="wrap-list dark">
  
    <li><a href="/tag/Android/">🏷️ Android</a></li>
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <p><code>Android</code> 图形 <code>Graphic</code> 和显示 <code>Display</code> 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 <code>BufferQueue</code> 生产者消费者模型， <code>Surface/SurfaceFlinger</code> 图形合成等等。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>应用开发者可通过两种方式将图像绘制到屏幕上：使用 <code>Canvas</code> 或 <code>OpenGL</code> ：</p>
<ul>
<li><code>android.graphics.Canvas</code> 是一个 <code>2D</code> 图形 <code>API</code> ， <code>Canvas API</code> 通过一个名为 <code>OpenGLRenderer</code> 的绘制库实现硬件加速，该绘制库将 <code>Canvas</code> 运算转换为 <code>OpenGL</code> 运算，以便它们可以在 <code>GPU</code> 上执行。从 <code>Android 4.0</code> 开始，硬件加速的 <code>Canvas</code> 默认情况下处于启用状态</li>
<li>除了 <code>Canvas</code>，开发者渲染图形的另一个主要方式是使用 <code>OpenGL ES</code> 直接渲染到 <code>Surface</code> 。 <code>Android</code> 在 <code>Android.opengl</code> 软件包中提供了 <code>OpenGL ES</code> 接口</li>
</ul>
<h3 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h3><p>先熟悉 <code>Android</code> 平台图形处理 <code>API</code> 的标准：</p>
<ul>
<li><code>OpenGL</code><br>  是由 <code>SGI</code> 公司开发的一套 <code>3D</code> 图形软件接口标准，由于具有体系结构简单合理、使用方便、与操作平台无关等优点， <code>OpenGL</code> 迅速成为 <code>3D</code> 图形接口的工业标准，并陆续在各种平台上得以实现。</li>
<li><code>OpenGL ES</code><br>  是由 <code>khronos</code> 组织根据手持及移动平台的特点，对 <code>OpenGL 3D</code> 图形 <code>API</code> 标准进行裁剪定制而形成的。</li>
<li><code>Vulkan</code><br>  是由 <code>khronos</code> 组织在 2016 年正式发布的，是 <code>OpenGL ES</code> 的继任者。 <code>API</code> 是轻量级、更贴近底层硬件 <code>close-to-the-metal</code> 的接口，可使 <code>GPU</code> 驱动软件运用多核与多线程 <code>CPU</code> 性能。</li>
</ul>
<p><code>OpenGL ES</code> 定义了一个渲染图形的 <code>API</code> ，但没有定义窗口系统。为了让它能够适合各种平台，它将与知道如何通过操作系统创建和访问窗口的库结合使用。而在 <code>Android</code> 中，这个库被称为 <code>EGL</code> ；也就是说 <code>EGL</code> 主要是适配系统和关联窗口属性。如果要绘制纹理多边形，应使用 <code>OpenGL ES</code> 调用；如果要在屏幕上进行渲染，应使用 <code>EGL</code> 调用。<br><code>OpenGL ES</code> 是 <code>Android</code> 绘图 <code>API</code> ，但 <code>OpenGL ES</code> 是平台通用的，在特定设备上使用需要一个中间层做适配， <code>Android</code> 中这个中间层就是 <code>EGL</code> 。</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-android-egl.jpg"></p>
<h3 id="Surface-SurfaceFlinger"><a href="#Surface-SurfaceFlinger" class="headerlink" title="Surface &amp; SurfaceFlinger"></a><code>Surface</code> &amp; <code>SurfaceFlinger</code></h3><p>无论开发者使用什么渲染 <code>API</code>，一切内容都会渲染到 <code>Surface</code> 。 <code>Surface</code> 表示缓冲队列中的生产者，而缓冲队列通常会被 <code>SurfaceFlinger</code> 消耗。在 <code>Android</code> 平台上创建的每个窗口都由 <code>Surface</code> 提供支持。所有被渲染的可见 <code>Surface</code> 都被 <code>SurfaceFlinger</code> 合成到显示部分。它们遵循生产者 &#x2F; 消费者模型：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-ape_fwk_graphics.png"></p>
<ul>
<li>图像流生产者<br>  图像流生产者可以是生成图形缓冲区以供消耗的任何内容。例如 <code>OpenGL ES, Canvas 2D, mediaserver</code> 视频解码器。</li>
<li>图像流消费者<br>  图像流的最常见消费者是 <code>SurfaceFlinger</code> ，该系统服务会消耗当前可见的 <code>Surface</code> ，并使用窗口管理器中提供的信息将它们合成到显示部分。 <code>SurfaceFlinger</code> 是可以修改所显示部分内容的唯一服务。 <code>SurfaceFlinger</code> 使用 <code>OpenGL</code> 和 <code>Hardware Composer</code> 来合成一组 <code>Surface</code> 。<br>  其他 <code>OpenGL ES</code> 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流。非 <code>GL</code> 应用也可以是消费者，例如 <code>ImageReader</code> 类。</li>
</ul>
<h3 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a><code>WMS</code></h3><p>窗口管理器（ WindowManagerServices），控制窗口的 <code>Android</code> 系统服务，它是视图容器。窗口总是由 <code>Surface</code> 提供支持。该服务会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、 <code>Z-Order</code> 以及窗口的其他许多方面。窗口管理器会将所有窗口元数据发送到 <code>SurfaceFlinger</code> ，以便 <code>SurfaceFlinger</code> 可以使用该数据在显示部分合成 <code>Surface</code> 。</p>
<h3 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a><code>FrameBuffer</code></h3><p><code>FrameBuffer</code> 帧缓冲驱动，它是 <code>Linux</code> 的一种驱动程序接口。 <code>Linux</code> 是工作在保护模式下，所以用户态进程是无法像 <code>DOS</code> 那样使用显卡 <code>BIOS</code> 里提供的中断调用来实现直接写屏， <code>Linux</code> 抽象出 <code>FrameBuffer</code> 这个设备来供用户态进程实现直接写屏。 <code>FrameBuffer</code> 机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过 <code>FrameBuffer</code> 的读写直接对显存进行操作。用户可以将 <code>FrameBuffer</code> 看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由 <code>FrameBuffer</code> 设备驱动来完成的。但 <code>FrameBuffer</code> 本身不具备任何运算数据的能力，就只好比是一个暂时存放水的水池。 <code>CPU</code> 将运算后的结果放到这个水池, 水池再将结果流到显示器，中间不会对数据做处理。应用程序也可以直接读写这个水池的内容在这种机制下，尽管 <code>FrameBuffer</code> 需要真正的显卡驱动的支持，但所有显示任务都有 <code>CPU</code> 完成，因此 <code>CPU</code> 负担很重。</p>
<p>在开发者看来， <code>FrameBuffer</code> 本质上是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说 <code>FrameBuffer</code> 就是一块白板。例如对于初始化为 16 位色的 <code>FrameBuffer</code> 来说， <code>FrameBuffer</code> 中的两个字节代表屏幕上一个点，从上到下，从左至右，屏幕位置与内存地址是顺序的线性关系。<br>帧缓存可以在系统存储器 (内存) 的任意位置，视频控制器通过访问帧缓存来刷新屏幕。帧缓存也叫刷新缓存 <code>FrameBuffer</code> 或 <code>RefreshBuffer</code> ，这里的帧 <code>Frame</code> 是指整个屏幕范围。帧缓存有个地址，是在内存里。我们通过不停的向 <code>FrameBuffer</code> 中写入数据，显示控制器就自动的从 <code>FrameBuffer</code> 中取数据并显示出来。全部的图形都共享内存中同一个帧缓存。</p>
<p><code>FrameBuffer</code> 帧缓冲实际上包括两个不同的方面：</p>
<ul>
<li><code>Frame</code> ：帧，就是指一幅图像，在屏幕上看到的那幅图像就是一帧</li>
<li><code>Buffer</code> ：缓冲，就是一段存储区域，可这个区域存储的是帧</li>
</ul>
<p><code>FrameBuffer</code> 就是一个存储图形 &#x2F; 图像帧数据的缓冲。<code>Linux</code> 内核提供了统一的 <code>Framebuffer</code> 显示驱动，设备节点 <code>/dev/graphics/fb*</code> 或者 <code>/dev/fb*</code> ，以 <code>fb0</code> 表示第一个 <code>Monitor</code> ，当前实现中只用到了一个显示屏。这个虚拟设备将不同硬件厂商实现的真实设备统一在一个框架下，这样应用层就可以通过标准的接口进行图形 &#x2F; 图像的输入和输出了：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-linux-framebuffer.png"></p>
<p>从上图中可以看出，应用层通过标准的 <code>ioctl, mmap</code> 等系统调用，就可以操作显示设备，用起来非常方便。这里 <code>mmap</code> 把设备中的显存映射到用户空间的，在这块缓冲上写数据，就相当于在屏幕上绘画。</p>
<h3 id="Gralloc"><a href="#Gralloc" class="headerlink" title="Gralloc"></a><code>Gralloc</code></h3><p><code>Gralloc</code> 的含义为是 <code>Graphics Alloc</code> 图形分配 。 <code>Android</code> 系统在硬件抽象层中提供了一个 <code>Gralloc</code> 模块，封装了对 <code>Framebuffer</code> 的所有访问操作。</p>
<p><code>Gralloc</code> 模块符合 <code>Android</code> 标准的 <code>HAL</code> 架构设计；它分为 <code>fb</code> 和 <code>gralloc</code> 两个设备：前者负责打开内核中的 <code>Framebuffer</code> 、初始化配置，以及提供 <code>post, setSwapInterval</code> 等操作；后者则管理帧缓冲区的分配和释放。上层只能通过 <code>Gralloc</code> 访问帧缓冲区，这样一来就实现了有序的封装保护。</p>
<p><code>Gralloc</code> 图形内存分配器，分配图像生产者请求的内存。它不仅仅是在原生堆上分配内存的另一种方法；在某些情况下，分配的内存可能并非缓存一致，或者可能完全无法从用户空间访问。分配的性质由用法标记确定，这些标记包括以下属性：</p>
<ul>
<li>从软件 <code>CPU</code> 访问内存的频率</li>
<li>从硬件 <code>GPU</code> 访问内存的频率</li>
<li>是否将内存用作 <code>OpenGL ES: GLES</code> 纹理</li>
<li>视频编码器是否会使用内存</li>
</ul>
<p>例如如果格式指定为 <code>RGBA 8888</code> 像素，并且指明将从软件访问缓冲区（这意味着应用将直接触摸像素），则分配器必须按照 <code>R-G-B-A</code> 的顺序为每个像素创建 4 个字节的缓冲区。相反如果指明仅从硬件访问缓冲区且缓冲区作为 <code>GLES</code> 纹理，则分配器可以执行 <code>GLES</code> 驱动程序所需的任何操作 - <code>BGRA</code> 排序、非线性搅和布局、替代颜色格式等。允许硬件使用其首选格式可以提高性能。某些值在特定平台上无法组合，例如视频编码器标记可能需要 <code>YUV</code> 像素，因此将无法添加软件访问权并指定 <code>RGBA 8888</code> 。</p>
<p><code>Gralloc</code> 分配器返回的句柄可以通过 <code>Binder</code> 在进程之间传递。</p>
<h3 id="HWC"><a href="#HWC" class="headerlink" title="HWC"></a><code>HWC</code></h3><p><code>HWC: Hardware Composer</code> 硬件混合渲染器，显示子系统的硬件抽象实现。 <code>SurfaceFlinger</code> 可以将某些合成工作委托给 <code>Hardware Composer</code>，以分担 <code>OpenGL</code> 和 <code>GPU</code> 上的工作量。 <code>SurfaceFlinger</code> 只是充当另一个 <code>OpenGL ES</code> 客户端。因此在 <code>SurfaceFlinger</code> 将一个或两个缓冲区合成到第三个缓冲区中的过程中，它会使用 <code>OpenGL ES</code> 。这样使合成的功耗比通过 <code>GPU</code> 执行所有计算更低。<br><code>Hardware Composer HAL</code> 则进行另一半的工作，并且是所有 <code>Android</code> 图形渲染的核心。 <code>Hardware Composer</code> 必须支持事件，其中之一是 <code>VSYNC</code>（另一个是支持即插即用 <code>HDMI</code> 的热插拔 <code>hotplug</code> ）。</p>
<h3 id="VSYNC-垂直刷新"><a href="#VSYNC-垂直刷新" class="headerlink" title="VSYNC 垂直刷新"></a>VSYNC 垂直刷新</h3><p>先介绍几个概念：</p>
<p>显卡处理图像的帧速率和屏幕刷新频率是相互独立的，当两者不一致时会出现 <code>tearing</code> 问题，为了解决不一致的问题，引入了 <code>Vsync</code> 信号：当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，等待定期同步信号 <code>VSync</code> 信号，收到后才开始下一次屏幕刷新；所以 <code>VSync</code> 中的 <code>V</code> 指的是垂直刷新中的垂直 <code>Vertical</code> 。<br><code>Vsync</code> 技术意味着，显卡显示性能极限被限制在屏幕刷新率以内了：在系统显卡处理的 <code>FPS</code> 高于屏幕刷新率时，显卡会将一部分时间浪费在等待上；因为没有可用的内存用于绘制，显卡需要等待 <code>Vsync</code> 信号才能绘制下一帧。</p>
<ul>
<li><p>单缓存缓存模型<br>  理想的情况是帧率和刷新频率相等，每绘制一帧，屏幕显示一帧，如下图所示；但是如果不一致，就会出现 <code>tearing</code> 。</p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-single-buffer.png"></p>
</li>
<li><p>双重缓存 <code>Double Buffer</code><br>  两个缓存区分别为 <code>Back Buffer</code> 和 <code>Frame Buffer</code> 。 <code>GPU</code> 向 <code>Back Buffer</code> 中写数据，屏幕从 <code>Frame Buffer</code> 中读数据。当屏幕刷新完成后产生 <code>VSync</code> 信号，此时将数据从 <code>Back Buffer</code> 复制到 <code>Frame Buffer</code>，可认为该复制操作在瞬间完成；复制完后显示设备开始显示这帧数据，同时通知 <code>CPU/GPU</code> 绘制下一帧图像。</p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer.png"></p>
<p>  但是当 <code>GPU/CPU</code> 绘制一帧的时间超过了 <code>Vsync</code> 时，屏幕刷新从 <code>Frame Buffer</code> 取到的数据仍然是上一帧数据，即两个 <code>Vsync</code> 周期显示同一帧数据，我们称为发生了掉帧 <code>Dropped Frame, Skipped Frame, Jank</code> 现象。  </p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-double-buffer-jank.png"></p>
</li>
<li><p>三重缓存 <code>Triple Buffer</code><br>  在双重缓存模型中，当 <code>Jank</code> 现象出现时， <code>GPU/CPU</code> 此时都处于闲置状态，所以引入了三重缓存的概念：在 <code>Jank</code> 时， <code>GPU/CPU</code> 在第三个 <code>Buffer</code> 中绘制数据：  </p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer.png"></p>
<p>  需要注意的是，第三个缓存并不是总是存在的，只要当需要的时候才会创建；而且也无法完全解决 <code>Jank</code> 现象，但是能缓解。  </p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-vsync-triple-buffer-jank.png"></p>
</li>
</ul>
<h3 id="60Hz-和-16-ms"><a href="#60Hz-和-16-ms" class="headerlink" title="60Hz 和 16 ms"></a>60Hz 和 16 ms</h3><p>从上面解释帧速率时提到，虽然人眼感知生理的极限 <code>85fps</code> ，但达到 <code>60fps</code> 时动画就已经有很好的体验，不会出现卡顿和迟滞现象；而最为关键的是 <code>60Hz</code> 是美国交流电的频率，如果屏幕刷新频率能够匹配交流电的频率就可以有效的预防屏幕中出现滚动条；所以：</p>
<ul>
<li><code>60Hz</code> 的屏幕刷新率或者 <code>60fps</code> 的帧率，是人眼能够感知到比较流畅的数值</li>
<li><code>1000ms/60=16ms</code> ， <code>16ms</code> 是指 <code>GPU/CPU</code> 在绘制图形时，必须在这个刷新频率内绘制完成，否则会出现丢帧现象</li>
</ul>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a><code>BufferQueue</code></h3><p>实现了整个生产者消费者模型。 <code>BufferQueues</code> 是 <code>Android</code> 图形组件之间的粘合剂。它们是一对队列，可以调解缓冲区从生产者到消费者的固定周期。一旦生产者移交其缓冲区， <code>SurfaceFlinger</code> 便会负责将所有内容合成到显示部分。<br><code>BufferQueue</code> 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作）；相反<strong>缓冲区始终通过句柄进行传递</strong>。</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-bufferqueue.png"></p>
<p><code>BufferQueue</code> 包含将图像流生产者与图像流消费者结合在一起的逻辑。图像生产者的一些示例包括由相机 <code>HAL</code> 或 <code>OpenGL ES</code> 游戏生成的相机预览。图像消费者的一些示例包括 <code>SurfaceFlinger</code> 或显示 <code>OpenGL ES</code> 流的另一个应用，如显示相机取景器的相机应用。<br><code>BufferQueue</code> 是将缓冲区池与队列相结合的数据结构，它使用 <code>Binder IPC</code> 在进程之间传递缓冲区。生产者接口，或者您传递给想要生成图形缓冲区的某个人的内容，即是 <code>IGraphicBufferProducer</code> （ <code>SurfaceTexture</code> 的一部分）。 <code>BufferQueue</code> 通常用于渲染到 <code>Surface</code> ，并且与 <code>GL</code> 消费者及其他任务一起消耗内容。 <code>BufferQueue</code> 可以在三种不同的模式下运行：</p>
<ul>
<li>类同步模式<br>  默认情况下， <code>BufferQueue</code> 在类同步模式下运行，在该模式下，从生产者进入的每个缓冲区都在消费者那退出。在此模式下不会舍弃任何缓冲区。如果生产者速度太快，创建缓冲区的速度比消耗缓冲区的速度更快，它将阻塞并等待可用的缓冲区。</li>
<li>非阻塞模式<br>  <code>BufferQueue</code> 还可以在非阻塞模式下运行，在此类情况下，它会生成错误，而不是等待缓冲区。在此模式下也不会舍弃缓冲区。这有助于避免可能不了解图形框架的复杂依赖项的应用软件出现潜在死锁现象。</li>
<li>舍弃模式<br>  <code>BufferQueue</code> 可以配置为丢弃旧缓冲区，而不是生成错误或进行等待。例如，如果对纹理视图执行 <code>GL</code> 渲染并尽快绘制，则必须丢弃缓冲区。</li>
</ul>
<p>为了执行这项工作的大部分环节， <code>SurfaceFlinger</code> 就像另一个 <code>OpenGL ES</code> 客户端一样工作。例如当 <code>SurfaceFlinger</code> 正在积极地将一个缓冲区或两个缓冲区合成到第三个缓冲区中时，它使用的是 <code>OpenGL ES</code> 。</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>Android</code> 图形管道数据流如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-graphics_pipeline.png"></p>
<p>左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。 <code>SurfaceFlinger</code> 是合成器，而硬件混合渲染器是制作器。</p>
<h3 id="组件小结"><a href="#组件小结" class="headerlink" title="组件小结"></a>组件小结</h3><ul>
<li>低级别组件<ul>
<li><code>BufferQueue</code> 和 <code>gralloc</code> 。 <code>BufferQueue</code> 将可生成图形数据缓冲区的组件（生产者）连接到接受数据以便进行显示或进一步处理的组件（消费者）。通过供应商专用 <code>HAL</code> 接口实现的 <code>gralloc</code> 内存分配器将用于执行缓冲区分配任务。</li>
<li><code>SurfaceFlinger, Hardware Composer</code> 和虚拟显示屏。 <code>SurfaceFlinger</code> 接受来自多个源的数据缓冲区，然后将它们进行合成并发送到显示屏。 <code>Hardware Composer HAL (HWC)</code> 确定使用可用硬件合成缓冲区的最有效的方法，虚拟显示屏使合成输出可在系统内使用（录制屏幕或通过网络发送屏幕）。</li>
<li><code>Surface, Canvas, SurfaceHolder</code> 。 <code>Surface</code> 可生成一个通常由 <code>SurfaceFlinger</code> 使用的缓冲区队列。当渲染到 <code>Surface</code> 上时，结果最终将出现在传送给消费者的缓冲区中。 <code>Canvas API</code> 提供一种软件实现方法（支持硬件加速），用于直接在 <code>Surface</code> 上绘图（ <code>OpenGL ES</code> 的低级别替代方案）。与视图有关的任何内容均涉及到 <code>SurfaceHolder</code> ，其 <code>API</code> 可用于获取和设置 <code>Surface</code> 参数（如大小和格式）。</li>
<li><code>EGLSurface, OpenGL ES</code> 。 <code>OpenGL ES (GLES)</code> 定义了用于与 <code>EGL</code> 结合使用的图形渲染 <code>API</code> 。 <code>EGI</code> 是一个规定如何通过操作系统创建和访问窗口的库（要绘制纹理多边形，请使用 <code>GLES</code> 调用；要将渲染放到屏幕上，请使用 <code>EGL</code> 调用）。 <code>ANativeWindow</code> ，它是 <code>Java Surface</code> 类的 <code>C/C++</code> 等价类，用于通过原生代码创建 <code>EGL</code> 窗口 <code>Surface</code> 。</li>
<li><code>Vulkan</code> 。 <code>Vulkan</code> 是一种用于高性能 <code>3D</code> 图形的低开销、跨平台 <code>API</code> 。与 <code>OpenGL ES</code> 一样， <code>Vulkan</code> 提供用于在应用中创建高质量实时图形的工具。 <code>Vulkan</code> 的优势包括降低 <code>CPU</code> 开销以及支持 <code>SPIR-V</code> 二进制中间语言。</li>
</ul>
</li>
<li>高级别组件<ul>
<li><code>SurfaceView</code> 和 <code>GLSurfaceView</code> 。 <code>SurfaceView</code> 结合了 <code>Surface</code> 和 <code>View</code> 。 <code>SurfaceView</code> 的 <code>View</code> 组件由 <code>SurfaceFlinger</code> （而不是应用）合成，从而可以通过单独的线程 &#x2F; 进程渲染，并与应用界面渲染隔离。 <code>GLSurfaceView</code> 提供帮助程序类来管理 <code>EGL</code> 上下文、线程间通信以及与 <code>Activity</code> 生命周期的交互（但使用 <code>GLES</code> 时并不需要 <code>GLSurfaceView</code> ）。</li>
<li><code>SurfaceTexture</code> 。 <code>SurfaceTexture</code> 将 <code>Surface</code> 和 <code>GLES</code> 纹理相结合来创建 <code>BufferQueue</code> ，而应用是 <code>BufferQueue</code> 的消费者。当生产者将新的缓冲区排入队列时，它会通知应用。应用会依次释放先前占有的缓冲区，从队列中获取新缓冲区并执行 <code>EGL</code> 调用，从而使 <code>GLES</code> 可将此缓冲区作为外部纹理使用。 <code>Android 7.0</code> 增加了对安全纹理视频播放的支持，以便用户能够对受保护的视频内容进行 <code>GPU</code> 后处理。</li>
<li><code>TextureView</code> 。 <code>TextureView</code> 结合了 <code>View</code> 和 <code>SurfaceTexture</code> 。 <code>TextureView</code> 对 <code>SurfaceTexture</code> 进行包装，并负责响应回调以及获取新的缓冲区。在绘图时， <code>TextureView</code> 使用最近收到的缓冲区的内容作为其数据源，根据 <code>View</code> 状态指示，在它应该渲染的任何位置和以它应该采用的任何渲染方式进行渲染。 <code>View</code> 合成始终通过 <code>GLES</code> 来执行，这意味着内容更新可能会导致其他 <code>View</code> 元素重绘。</li>
</ul>
</li>
</ul>
<p>高级别组件可以直接在 <code>APP</code> 中使用。</p>
<h2 id="Buffer-Window-体系"><a href="#Buffer-Window-体系" class="headerlink" title="Buffer/Window 体系"></a><code>Buffer/Window</code> 体系</h2><h3 id="代码速查表"><a href="#代码速查表" class="headerlink" title="代码速查表"></a>代码速查表</h3><p>system&#x2F;core&#x2F;libcutils&#x2F;include&#x2F;cutils&#x2F;native_handle.h<br>hardware&#x2F;qcom&#x2F;display&#x2F;libgralloc&#x2F;gralloc_priv.h<br>frameworks&#x2F;native&#x2F;libs&#x2F;nativebase&#x2F;include&#x2F;nativebase&#x2F;nativebase.h<br>frameworks&#x2F;native&#x2F;libs&#x2F;nativewindow&#x2F;include&#x2F;system&#x2F;window.h<br>frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;include&#x2F;ui&#x2F;ANativeObjectBase.h<br>frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;include&#x2F;ui&#x2F;GraphicBuffer.h<br>frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;include&#x2F;gui&#x2F;Surface.h</p>
<h3 id="native-handle-buffer-handle-t"><a href="#native-handle-buffer-handle-t" class="headerlink" title="native_handle/buffer_handle_t"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#native-handle-buffer-handle-t" title="native_handle/buffer_handle_t"></a><code>native_handle/buffer_handle_t</code></h3><p>先看 <code>native_handle</code> 这个结构体的定义：</p>
<p>&#x2F;&#x2F; native_handle.h<br>typedef struct native_handle<br>{<br>    int version;        &#x2F;* sizeof(native_handle_t) <em>&#x2F;<br>    int numFds;         &#x2F;</em> number of file-descriptors at &amp;data[0] <em>&#x2F;<br>    int numInts;        &#x2F;</em> number of ints at &amp;data[numFds] <em>&#x2F;<br>#if defined(<strong>clang</strong>)<br>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wzero-length-array”<br>#endif<br>    int data[0];        &#x2F;</em> numFds + numInts ints *&#x2F;<br>#if defined(<strong>clang</strong>)<br>#pragma clang diagnostic pop<br>#endif<br>} native_handle_t;</p>
<p>typedef const native_handle_t* buffer_handle_t;</p>
<p><code>native_handle</code> 这个结构体，描述了一个数据结构，其中最关键的是 <code>data[0]</code> ，它是一个长度为 0 的数组，即 <code>native_handle</code> 是一个柔性数组。在标准的 <code>C/C++</code> 中, 长度为 0 的数组是不被允许的，编译时会产生错误！长度为 0 的数组是 <code>C/C++</code> 的扩展，需要当前编译器支持这个扩展。从头文件注释中也可以看出，当使用的是 <code>clang</code> 编译器时，才会定义 <code>data[0]</code> 并且忽略数组为 0 的警告。</p>
<p>从 <code>C/C++</code> 中柔性数组的用途来看， <code>native_handle</code> 表示的是一个不定长数据结构，实际意义指向连续分配的内存空间（除了 <code>native_handle</code> 之外）代表的数据结构（通常是 <code>private_handle_t</code> ）。这里这么做，是因为显示系统和每家实现平台相关度很高， <code>native_handle</code> 定义一个通用的数据结构，至于显示系统如何显示，每家自己去实现对应的 <code>private_handle_t</code> 。</p>
<p><code>native_handle</code> 结构体中的注释写的很清楚， <code>numFds</code> 表示被指向数据结构包含几个文件描述符； <code>numInts</code> 表示被指向数据结构长度是多少个整型；有了这两个信息后，内存分配就很容易了，参考 <code>native_handle_create</code> 的源码实现：</p>
<p>&#x2F;&#x2F; native_handle.c<br>native_handle_t* native_handle_create(int numFds, int numInts) {<br>    if (numFds &lt; 0 || numInts &lt; 0 || numFds &gt; kMaxNativeFds<br>            || numInts &gt; kMaxNativeInts) {<br>        errno &#x3D; EINVAL;<br>        return NULL;<br>    }</p>
<pre><code>// 给 native_handle 分配连续的内存空间
// 除了 native_handle 自身所占空间，还包含被指向数据结构的长度  
size_t mallocSize = sizeof(native_handle_t) 
    + (sizeof(int) * (numFds + numInts));
native_handle_t* h = malloc(mallocSize);
if (h) &#123;
    h-&gt;version = sizeof(native_handle_t);
    h-&gt;numFds = numFds;
    h-&gt;numInts = numInts;
&#125;
return h;
</code></pre>
<p>}</p>
<p>小结： <code>native_handle, native_handle_t</code> 表示一个不定长数据结构，而 <code>buffer_handle_t</code> 表示指向 <code>native_handle</code> 的指针。</p>
<h3 id="private-handle-t"><a href="#private-handle-t" class="headerlink" title="private_handle_t"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#private-handle-t" title="private_handle_t"></a><code>private_handle_t</code></h3><p><code>private_handle_t</code> 描述的是一块缓存，因为和实现平台高度相关，我这里选取高通平台，先看头文件定义：</p>
<p>&#x2F;&#x2F; gralloc_priv.h<br>#ifdef __cplusplus<br>struct private_handle_t : public native_handle {<br>#else<br>    struct private_handle_t {<br>        native_handle_t nativeHandle;<br>#endif<br>        enum {<br>            PRIV_FLAGS_FRAMEBUFFER        &#x3D; 0x00000001,<br>            …<br>        };</p>
<pre><code>    // file-descriptors
    int     fd;
    int     fd_metadata;          // fd for the meta-data
    // ints
    int     magic;
    int     flags;
    unsigned int  size;
    unsigned int  offset;
    int     bufferType;
    uint64_t base __attribute__((aligned(8)));
    unsigned int  offset_metadata;
    // The gpu address mapped into the mmu.
    uint64_t gpuaddr __attribute__((aligned(8)));
    int     format;
    int     width;   // holds aligned width of the actual buffer allocated
    int     height;  // holds aligned height of the  actual buffer allocated
    uint64_t base_metadata __attribute__((aligned(8)));
    int unaligned_width;   // holds width client asked to allocate
    int unaligned_height;  // holds height client asked to allocate
</code></pre>
<p>#ifdef __cplusplus<br>        static const int sNumFds &#x3D; 2;<br>        static inline int sNumInts() {<br>            return ((sizeof(private_handle_t) - sizeof(native_handle_t)) &#x2F;<br>                    sizeof(int)) - sNumFds;<br>        }<br>        static const int sMagic &#x3D; ‘gmsm’;<br>        …<br>}</p>
<p><code>private_handle_t</code> 描述了缓存区使用的文件描述符 <code>fd, fd_metadata</code> 、大小、偏移量、基地址、长宽、格式、没有对齐的长宽等等，而 <code>sNumFds</code> 对应 <code>nativeHandle.numFds</code> ； <code>sNumInts</code> 对应 <code>nativeHandle.numInts</code> ，即除了文件描述符之外，该数据结构的长度。<br>小结： <code>private_handle_t</code> 在各个模块之间传递的时候很不方便，而如果用 <code>native_handle</code> 的来传递，就可以消除平台的差异性。一个简单示意图描述两者的关系：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0109-android-camera-5-hal-buffer_handle_t.png"></p>
<p>至此，我们可以简单的理解为 <code>native_handle, native_handle_t, private_handle_t, buffer_handle_t</code> 表示的是同一块内存。</p>
<h3 id="ANativeWindowBuffer"><a href="#ANativeWindowBuffer" class="headerlink" title="ANativeWindowBuffer"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#ANativeWindowBuffer" title="ANativeWindowBuffer"></a><code>ANativeWindowBuffer</code></h3><p>先了解 <code>android_native_base_t</code> 数据结构的定义：</p>
<p>typedef struct android_native_base_t<br>{<br>    &#x2F;* a magic value defined by the actual EGL native type *&#x2F;<br>    int magic;</p>
<pre><code>/* the sizeof() of the actual EGL native type */
int version;

void* reserved[4];

/* reference-counting interface */
void (*incRef)(struct android_native_base_t* base);
void (*decRef)(struct android_native_base_t* base);
</code></pre>
<p>} android_native_base_t;</p>
<p><code>android_native_base_t</code> 中 <code>incRef/decRef</code> 主要功能是：为了把派生类和 <code>Android</code> 所有 <code>class</code> 的老祖宗 <code>RefBase</code> 联系起来所预留的函数指针。</p>
<p>再看 <code>ANativeWindowBuffer</code> 数据结构的定义：</p>
<p>&#x2F;&#x2F; nativebase.h<br>typedef struct ANativeWindowBuffer<br>{<br>#ifdef __cplusplus<br>    ANativeWindowBuffer() {<br>        common.magic &#x3D; ANDROID_NATIVE_BUFFER_MAGIC;<br>        common.version &#x3D; sizeof(ANativeWindowBuffer);<br>        memset(common.reserved, 0, sizeof(common.reserved));<br>    }</p>
<pre><code>// Implement the methods that sp&lt;ANativeWindowBuffer&gt; expects so that it
// can be used to automatically refcount ANativeWindowBuffer&#39;s.
void incStrong(const void* /*id*/) const &#123;
    common.incRef(const_cast&lt;android_native_base_t*&gt;(&amp;common));
&#125;
void decStrong(const void* /*id*/) const &#123;
    common.decRef(const_cast&lt;android_native_base_t*&gt;(&amp;common));
&#125;
</code></pre>
<p>#endif</p>
<pre><code>struct android_native_base_t common;

int width;
int height;
int stride;
int format;
int usage_deprecated;
uintptr_t layerCount;

void* reserved[1];

const native_handle_t* handle;
uint64_t usage;

// we needed extra space for storing the 64-bits usage flags
// the number of slots to use from reserved_proc depends on the
// architecture.
void* reserved_proc[8 - (sizeof(uint64_t) / sizeof(void*))];
</code></pre>
<p>} ANativeWindowBuffer_t;</p>
<p>typedef struct ANativeWindowBuffer ANativeWindowBuffer;</p>
<p>&#x2F;&#x2F; Old typedef for backwards compatibility.<br>typedef ANativeWindowBuffer_t android_native_buffer_t;</p>
<p><code>ANativeWindowBuffer</code> 中使用了 <code>native_handle_t</code> 指针，同时该结构体中也有长宽、格式、步进等基本描述信息；也就是 <code>ANativeWindowBuffer</code> 描述的是一块 <code>Window</code> 相关的缓存区。</p>
<h3 id="ANativeWindow"><a href="#ANativeWindow" class="headerlink" title="ANativeWindow"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#ANativeWindow" title="ANativeWindow"></a><code>ANativeWindow</code></h3><p><code>ANativeWindow</code> 数据结构的定义：</p>
<p>&#x2F;&#x2F; window.h<br>struct ANativeWindow<br>{<br>#ifdef __cplusplus<br>    ANativeWindow()<br>        : flags(0), minSwapInterval(0), maxSwapInterval(0), xdpi(0), ydpi(0)<br>    {<br>        common.magic &#x3D; ANDROID_NATIVE_WINDOW_MAGIC;<br>        common.version &#x3D; sizeof(ANativeWindow);<br>        memset(common.reserved, 0, sizeof(common.reserved));<br>    }</p>
<pre><code>/* Implement the methods that sp&lt;ANativeWindow&gt; expects so that it
   can be used to automatically refcount ANativeWindow&#39;s. */
void incStrong(const void* /*id*/) const &#123;
    common.incRef(const_cast&lt;android_native_base_t*&gt;(&amp;common));
&#125;
void decStrong(const void* /*id*/) const &#123;
    common.decRef(const_cast&lt;android_native_base_t*&gt;(&amp;common));
&#125;
</code></pre>
<p>#endif</p>
<pre><code>struct android_native_base_t common;

/* flags describing some attributes of this surface or its updater */
const uint32_t flags;

/* min swap interval supported by this updated */
const int   minSwapInterval;

/* max swap interval supported by this updated */
const int   maxSwapInterval;

/* horizontal and vertical resolution in DPI */
const float xdpi;
const float ydpi;

/* Some storage reserved for the OEM&#39;s driver. */
intptr_t    oem[4];

int     (*setSwapInterval)(struct ANativeWindow* window,
            int interval);
int     (*dequeueBuffer_DEPRECATED)(struct ANativeWindow* window,
            struct ANativeWindowBuffer** buffer);
int     (*lockBuffer_DEPRECATED)(struct ANativeWindow* window,
            struct ANativeWindowBuffer* buffer);
int     (*queueBuffer_DEPRECATED)(struct ANativeWindow* window,
            struct ANativeWindowBuffer* buffer);
int     (*query)(const struct ANativeWindow* window,
            int what, int* value);
int     (*perform)(struct ANativeWindow* window,
            int operation, ... );
int     (*cancelBuffer_DEPRECATED)(struct ANativeWindow* window,
            struct ANativeWindowBuffer* buffer);
int     (*dequeueBuffer)(struct ANativeWindow* window,
            struct ANativeWindowBuffer** buffer, int* fenceFd);
int     (*queueBuffer)(struct ANativeWindow* window,
            struct ANativeWindowBuffer* buffer, int fenceFd);
int     (*cancelBuffer)(struct ANativeWindow* window,
            struct ANativeWindowBuffer* buffer, int fenceFd);
</code></pre>
<p>};</p>
<p> &#x2F;* Backwards compatibility: use ANativeWindow (struct ANativeWindow in C).</p>
<ul>
<li>android_native_window_t is deprecated.<br>  *&#x2F;<br>typedef struct ANativeWindow android_native_window_t __deprecated;</li>
</ul>
<p>从数据结构定义中可以看出， <code>ANativeWindow</code> 和窗口属性相关，它表示的是一个底层实现的窗口，定义的各种函数指针都是对 <code>ANativeWindowBuffer</code> 内存的操作；而 <code>fenceFd</code> 可以看成这个 <code>buffer</code> 的锁。</p>
<p>小结：不管是 <code>ANativeWindow, ANativeWindowBuffer</code> 它们都包含 <code>android_native_base_t</code> 结构体，但是都没有对 <code>incRef, decRef</code> 赋值；可以认为 <code>ANativeWindow, ANativeWindowBuffer</code> 为抽象数据结构。</p>
<h3 id="ANativeObjectBase-模板"><a href="#ANativeObjectBase-模板" class="headerlink" title="ANativeObjectBase 模板"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#ANativeObjectBase-%E6%A8%A1%E6%9D%BF" title="ANativeObjectBase 模板"></a><code>ANativeObjectBase</code> 模板</h3><p><code>ANativeObjectBase</code> 是一个模板类，定义如下：</p>
<p>&#x2F;&#x2F; ANativeObjectBase.h<br>template &lt;typename NATIVE_TYPE, typename TYPE, typename REF,<br>        typename NATIVE_BASE &#x3D; android_native_base_t&gt;<br>class ANativeObjectBase : public NATIVE_TYPE, public REF<br>{<br>public:<br>    &#x2F;&#x2F; Disambiguate between the incStrong in REF and NATIVE_TYPE<br>    void incStrong(const void* id) const {<br>        REF::incStrong(id);<br>    }<br>    void decStrong(const void* id) const {<br>        REF::decStrong(id);<br>    }</p>
<p>protected:<br>    typedef ANativeObjectBase&lt;NATIVE_TYPE, TYPE, REF, NATIVE_BASE&gt; BASE;<br>    ANativeObjectBase() : NATIVE_TYPE(), REF() {<br>        NATIVE_TYPE::common.incRef &#x3D; incRef;<br>        NATIVE_TYPE::common.decRef &#x3D; decRef;<br>    }<br>    static inline TYPE* getSelf(NATIVE_TYPE* self) {<br>        return static_cast&lt;TYPE*&gt;(self);<br>    }<br>    static inline TYPE const* getSelf(NATIVE_TYPE const* self) {<br>        return static_cast&lt;TYPE const <em>&gt;(self);<br>    }<br>    static inline TYPE</em> getSelf(NATIVE_BASE* base) {<br>        return getSelf(reinterpret_cast&lt;NATIVE_TYPE*&gt;(base));<br>    }<br>    static inline TYPE const * getSelf(NATIVE_BASE const* base) {<br>        return getSelf(reinterpret_cast&lt;NATIVE_TYPE const*&gt;(base));<br>    }<br>    static void incRef(NATIVE_BASE* base) {<br>        ANativeObjectBase* self &#x3D; getSelf(base);<br>        self-&gt;incStrong(self);<br>    }<br>    static void decRef(NATIVE_BASE* base) {<br>        ANativeObjectBase* self &#x3D; getSelf(base);<br>        self-&gt;decStrong(self);<br>    }<br>};</p>
<p>} &#x2F;&#x2F; namespace android<br>#endif &#x2F;&#x2F; __cplusplus</p>
<p><code>ANativeObjectBase</code> 模板类的主要作用就是实现 <code>incRef, decRef</code> 引用计数，以及父类子类的类型转换。</p>
<h3 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#GraphicBuffer" title="GraphicBuffer"></a><code>GraphicBuffer</code></h3><p>先看 <code>GraphicBuffer</code> 的头文件定义：</p>
<p>&#x2F;&#x2F; GraphicBuffer.h<br>class GraphicBuffer<br>    : public ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer, RefBase&gt;,<br>      public Flattenable<GraphicBuffer><br>{…}</p>
<p><code>GraphicBuffer</code> 使用 <code>ANativeObjectBase</code> 模板，即 <code>GraphicBuffer</code> 就是 <code>ANativeWindowBuffer</code> 的一种具体实现；而 <code>ANativeWindowBuffer.common</code> 成员的两个函数指针 <code>incRef, decRef</code> 指向了 <code>GraphicBuffer</code> 的另一个基类 <code>RefBase</code> 的 <code>incStrong, decStrong</code> ；而 <code>ANativeWindowBuffer</code> 可以看做是把 <code>buffer_handle_t</code> 包了一层，所以 <code>GraphicBuffer</code> 也是指向的一块缓存区。</p>
<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#Surface" title="Surface"></a><code>Surface</code></h3><p><code>Surface</code> 的头文件定义：</p>
<p>&#x2F;&#x2F; Surface.h<br>class Surface<br>    : public ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;<br>{<br>    …<br>protected:<br>    …<br>    struct BufferSlot {<br>        sp<GraphicBuffer> buffer;<br>        Region dirtyRegion;<br>    };<br>    BufferSlot mSlots[NUM_BUFFER_SLOTS];<br>    …<br>}</p>
<p><code>Surface</code> 也使用了 <code>ANativeObjectBase</code> 模板，即 <code>Surface</code> 就是 <code>ANativeWindow</code> 的一种具体实现，同样也继承了 <code>RefBase</code> 实现引用计数。另外成员数据结构 <code>BufferSlot</code> 是对 <code>GraphicBuffer</code> 的包装，而 <code>mSlots</code> 数组表示每个 <code>Surface</code> 中包含 <code>NUM_BUFFER_SLOTS</code> 个 <code>GraphicBuffer</code> 缓存。<br>而 <code>Surface</code> 的构造函数中，也将 <code>ANativeWindow</code> 的函数指针进行了赋值：</p>
<p>&#x2F;&#x2F; Surface.cpp<br>Surface::Surface(const sp<IGraphicBufferProducer>&amp; bufferProducer,<br>    bool controlledByApp)<br>      : mGraphicBufferProducer(bufferProducer),<br>        mCrop(Rect::EMPTY_RECT),<br>        mBufferAge(0),<br>        mGenerationNumber(0),<br>        mSharedBufferMode(false),<br>        mAutoRefresh(false),<br>        mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),<br>        mSharedBufferHasBeenQueued(false),<br>        mQueriedSupportedTimestamps(false),<br>        mFrameTimestampsSupportsPresent(false),<br>        mEnableFrameTimestamps(false),<br>       mFrameEventHistory(std::make_unique<ProducerFrameEventHistory>()){<br>    &#x2F;&#x2F; Initialize the ANativeWindow function pointers.<br>    ANativeWindow::setSwapInterval  &#x3D; hook_setSwapInterval;<br>    ANativeWindow::dequeueBuffer    &#x3D; hook_dequeueBuffer;<br>    ANativeWindow::cancelBuffer     &#x3D; hook_cancelBuffer;<br>    ANativeWindow::queueBuffer      &#x3D; hook_queueBuffer;<br>    ANativeWindow::query            &#x3D; hook_query;<br>    ANativeWindow::perform          &#x3D; hook_perform;<br>    …<br>}</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%B0%8F%E7%BB%93" title="小结"></a>小结</h3><ul>
<li><code>native_handle/native_handle_t</code> 是 <code>private_handle_t</code> 的抽象表示方法，消除平台相关性；方便 <code>private_handle_t</code> 所表示的缓存区可以在 <code>Android</code> 各个层次之间传递；而 <code>buffer_handle_t</code> 是指向他们的指针</li>
<li><code>ANativeWindowBuffer</code> 将 <code>buffer_handle_t</code> 进行了包装；<code>ANativeWindow, ANativeWindowBuffer</code> 都继承于 <code>android_native_base_t</code> ，它定义了引用计数两个函数指针；可以认为 <code>ANativeWindow, ANativeWindowBuffer</code> 为抽象数据结构，表示窗口和其对应缓存</li>
<li><code>GraphicBuffer, Surface</code> 都使用了模版类 <code>ANativeObjectBase</code> ，都继承了 <code>RefBase</code> 实现 <code>incRef, decRef</code> 引用计数；它们是具体的实现类，即实现具体的窗口缓存和窗口</li>
<li><code>Surface</code> 的成员 <code>BufferSlot mSlots[NUM_BUFFER_SLOTS];</code> 可以看作是 <code>sp&lt;GraphicBuffer&gt;</code> 类型的数组；也就是说每个 <code>Surface</code> 中都包含有 <code>NUM_BUFFER_SLOTS</code> 个 <code>GraphicBuffer</code></li>
<li><code>Surface, GraphicBuffer</code> 是图形显示系统的高层类，后续主要围绕这两个类来介绍；一个代表窗口，一个代表窗口对应的缓存</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/606437-20bbb0ebba7fd244.png">Buffer&#x2F;Window 体系缓存，查看大图</a></p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-surface-buffer.png"></p>
<p><code>BufferQueue</code> 中的 <code>Buffer</code> 对象，我们用的都是 <code>GraphicBuffer</code> 。 <code>Surface</code> 是 <code>Andorid</code> 窗口的描述，是 <code>ANativeWindow</code> 的实现；同样 <code>GraphicBuffer</code> 是 <code>Android</code> 中图形 <code>Buffer</code> 的描述，是 <code>ANativeWindowBuffer</code> 的实现。而一个窗口可以有多个 <code>Buffer</code> 。</p>
<h2 id="libui-库"><a href="#libui-库" class="headerlink" title="libui 库"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#libui-%E5%BA%93" title="libui 库"></a><code>libui</code> 库</h2><p><code>libui.so</code> 库主要是 <code>GraphicBuffer</code> 缓存相关的代码，包含缓存分配，映射当当前进程等等，而 <code>IAllocator, IMapper</code> 具体是在 <code>HAL</code> 中实现的。</p>
<h3 id="代码目录结构"><a href="#代码目录结构" class="headerlink" title="代码目录结构"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" title="代码目录结构"></a>代码目录结构</h3><p><code>frameworks/native/libs/ui</code> 目录结构：</p>
<p>ui<br>├── Android.bp<br>├── ColorSpace.cpp<br>├── DebugUtils.cpp<br>├── Fence.cpp<br>├── FenceTime.cpp<br>├── FrameStats.cpp<br>├── Gralloc2.cpp<br>├── GraphicBufferAllocator.cpp<br>├── GraphicBuffer.cpp<br>├── GraphicBufferMapper.cpp<br>├── HdrCapabilities.cpp<br>├── include<br>│   └── ui<br>│       ├── ANativeObjectBase.h<br>│       ├── BufferQueueDefs.h<br>│       ├── ColorSpace.h<br>│       ├── DebugUtils.h<br>│       ├── DisplayInfo.h<br>│       ├── DisplayStatInfo.h<br>│       ├── Fence.h<br>│       ├── FenceTime.h<br>│       ├── FloatRect.h<br>│       ├── FrameStats.h<br>│       ├── Gralloc2.h<br>│       ├── GraphicBufferAllocator.h<br>│       ├── GraphicBuffer.h<br>│       ├── GraphicBufferMapper.h<br>│       ├── HdrCapabilities.h<br>│       ├── PixelFormat.h<br>│       ├── Point.h<br>│       ├── Rect.h<br>│       ├── Region.h<br>│       └── UiConfig.h<br>├── MODULE_LICENSE_APACHE2<br>├── NOTICE<br>├── PixelFormat.cpp<br>├── Rect.cpp<br>├── Region.cpp<br>├── tests<br>│   ├── Android.bp<br>│   ├── colorspace_test.cpp<br>│   └── Region_test.cpp<br>├── tools<br>│   ├── Android.bp<br>│   └── lutgen.cpp<br>└── UiConfig.cpp</p>
<p>4 directories, 42 files</p>
<h3 id="GraphicBufferAllocator-GraphicBufferMapper"><a href="#GraphicBufferAllocator-GraphicBufferMapper" class="headerlink" title="GraphicBufferAllocator/GraphicBufferMapper"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#GraphicBufferAllocator-GraphicBufferMapper" title="GraphicBufferAllocator/GraphicBufferMapper"></a><code>GraphicBufferAllocator/GraphicBufferMapper</code></h3><p>它们两个都是包装类，包装了 <code>IAllocator, IMapper</code> ，而这两个类都是在 <code>HAL Gralloc2</code> 中实现的。</p>
<ul>
<li><code>GraphicBufferAllocator</code><br>  缓存分配，包装了 <code>IAllocator</code> 类。</li>
<li><code>GraphicBufferMapper</code><br>  缓存映射到当前进程，包装了 <code>IMapper</code> 类。</li>
</ul>
<h3 id="GraphicBuffer-1"><a href="#GraphicBuffer-1" class="headerlink" title="GraphicBuffer"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#GraphicBuffer-1" title="GraphicBuffer"></a><code>GraphicBuffer</code></h3><p><code>GraphicBuffer</code> 继承 <code>ANativeWindowBuffer</code> ，并持有 <code>GraphicBufferMapper</code> 映射对应的缓存区。</p>
<p>class GraphicBuffer :<br>    public ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer,RefBase&gt;,<br>    public Flattenable<GraphicBuffer><br>{<br>public:<br>    static sp<GraphicBuffer> from(ANativeWindowBuffer *);<br>    …<br>private:<br>    GraphicBufferMapper&amp; mBufferMapper;<br>    ssize_t mInitCheck;<br>    uint64_t mId;<br>    uint32_t mGenerationNumber;<br>};</p>
<h3 id="Fence-机制"><a href="#Fence-机制" class="headerlink" title="Fence 机制"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#Fence-%E6%9C%BA%E5%88%B6" title="Fence 机制"></a><code>Fence</code> 机制</h3><p><code>Fence</code> 是一种同步机制，主要用于 <code>GraphicBuffer</code> 的同步。它主要被用来处理跨硬件的情况，尤其是 <code>CPU, GPU, HWC</code> 之间的同步，另外它还可以用于多个时间点之间的同步。 <code>GPU</code> 编程和纯 <code>CPU</code> 编程一个很大的不同是它是异步的，也就是说当我们调用 <code>GL command</code> 返回时这条命令并不一定完成了，只是把这个命令放在本地的 <code>command buffer</code> 里，而 <code>Fence</code> 机制就是解决这些同步问题的。<br><code>Fence</code> 顾名思义就是把先到的拦住，等后来的，两者步调一致了再往前走。抽象地说，<code>Fence</code> 包含了同一或不同时间轴上的多个时间点，只有当这些点同时到达时 <code>Fence</code> 才会被触发。 <code>Fence</code> 可以由硬件实现 <code>Graphic driver</code>，也可以由软件实现 <code>Android kernel</code> 中的 <code>sw_sync</code> 。</p>
<p><code>Fence</code> 的主要实现代码路径：</p>
<p>frameworks&#x2F;native&#x2F;libs&#x2F;ui&#x2F;Fence.cpp<br>system&#x2F;core&#x2F;libsync&#x2F;sync.c<br>kernel&#x2F;drivers&#x2F;base&#x2F;sync.c<br>frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;SyncFeatures.cpp</p>
<p>总得来说， <code>kernel driver</code> 部分是同步的主要实现，<code>libsync</code> 是对 <code>driver</code> 接口的封装， <code>Fence</code> 是对 <code>libsync</code> 的进一步的 <code>C++</code> 封装。 <code>Fence</code> 会被作为 <code>GraphicBuffer</code> 的附属随着 <code>GraphicBuffer</code> 在生产者和消费间传输； <code>SyncFeatures</code> 用以查询系统支持的同步机制。</p>
<h3 id="DisplayInfo-显示信息"><a href="#DisplayInfo-显示信息" class="headerlink" title="DisplayInfo 显示信息"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#DisplayInfo-%E6%98%BE%E7%A4%BA%E4%BF%A1%E6%81%AF" title="DisplayInfo 显示信息"></a><code>DisplayInfo</code> 显示信息</h3><p>&#x2F;&#x2F; DisplayInfo.h<br>struct DisplayInfo {<br>    uint32_t w{0};                      &#x2F;&#x2F; 屏幕的宽<br>    uint32_t h{0};                      &#x2F;&#x2F; 屏幕的高<br>    float xdpi{0};                      &#x2F;&#x2F; 屏幕 x 方向每英寸的像素点<br>    float ydpi{0};                      &#x2F;&#x2F; 屏幕 y 方向每英寸的像素点<br>    float fps{0};                       &#x2F;&#x2F; FPS 屏幕的刷新率<br>    float density{0};                   &#x2F;&#x2F; 屏幕的密度<br>    uint8_t orientation{0};             &#x2F;&#x2F; 屏幕的旋转方式<br>    bool secure{false};                 &#x2F;&#x2F; 屏幕是否是安全的<br>    nsecs_t appVsyncOffset{0};          &#x2F;&#x2F; App 的 Vsync 的偏移<br>    nsecs_t presentationDeadline{0};    &#x2F;&#x2F; 显示的最后时间<br>};</p>
<p>&#x2F;* Display orientations as defined in Surface.java<br>    and ISurfaceComposer.h. *&#x2F;<br>enum {<br>    DISPLAY_ORIENTATION_0 &#x3D; 0,<br>    DISPLAY_ORIENTATION_90 &#x3D; 1,<br>    DISPLAY_ORIENTATION_180 &#x3D; 2,<br>    DISPLAY_ORIENTATION_270 &#x3D; 3<br>};</p>
<p>}; &#x2F;&#x2F; namespace android</p>
<p><code>DisplayInfo</code> 结构体包含了显示屏幕的基本信息：</p>
<ul>
<li><p>屏幕分辨率 <code>Resolution</code><br>  屏幕的宽高是用分辨率 <code>Resolution</code> 来描述的，也就是有多少个像素点。屏幕宽度，即屏幕横向可以显示多少个像素点；屏幕高度，即屏幕纵向可以显示多少给像素点。平常所说的 <code>720P: 1080x720</code> 屏幕，即横向可以显示 1080 个像素点，纵向可以显示 720 个像素点。如下为常见屏幕分辨率：  </p>
<p>  <img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-resolution.png"></p>
</li>
<li><p>屏幕 <code>DPI</code><br>  <code>DPI: Dots Per Inch</code> 每英寸点数，是一个度量单位，表示屏幕每英寸上有多少个物理点。常见屏幕物理大小，是用英寸来描述屏幕对角线的长度，比如 <code>IPhone X</code> 的大小 5.8 寸，即屏幕对角线长度为 5.8 英寸。* _标准 <code>DPI</code> 为 <code>160dpi</code> *_，人类视网膜级通常为 <code>300dpi</code> 。<br>  <code>PPI: Pixel Per Inch</code> 每英寸像素，也是度量单位，表示每英寸显示多少个像素。通常情况下 <code>DPI, PPI</code> 设为相同，表示每个物理点显示一个像素；但是好一点的显示器，可能 <code>DPI</code> 比 <code>PPI</code> 大，即一个像素由多个物理点来显示。</p>
</li>
<li><p>密度 <code>Density</code><br>  <code>DIP: Density Independent Pixels</code> 设备无关像素，通常简写为 <code>DP=DIP</code>，请注意 <code>DPI</code> 做好区分。 <code>DP</code> 表示这个像素的数值是和设备无关的，那实际转换时怎么转换呢？<br>  <code>Density</code> 密度，实际是一个缩放因子，它表示当前设备实际 <code>DPI</code> 和标准 <code>DPI</code> 的比例值；比如设备实际 <code>DPI</code> 为 <code>320dpi</code> ，那么 <code>density=320/160=2</code> ，即 <code>density</code> 为 2 。有了 <code>density</code> 之后， <code>dp, px</code> 可以使用公式来转换 <code>px=density*dp</code> 。<br>  所以我们在 <code>APP</code> 布局设计中，所有显示设置的距离，通常使用 <code>dp</code> 来计算，来规避不同屏幕特性。</p>
</li>
<li><p>屏幕刷新率 <code>FPS</code><br>  这里屏幕刷新率使用 <code>FPS</code> 来表示，不是 <code>Hz</code> ，表示屏幕每秒能显示多少帧数据；通常为 60 fps ，即 16 ms 刷新一次。</p>
</li>
<li><p>屏幕旋转方向 <code>orientations</code><br>  手机默认竖屏，0 表示竖屏， 180 表示横屏。</p>
</li>
<li><p>屏幕安全性 <code>secure</code><br>  这主要是用于 <code>DRM</code> 数字版权保护时，确保显示的设备是安全的，以防止 <code>DRM</code> 的内容被在显示的过程中被截取，只有安全的设备才能显示 <code>DRM</code> 的内容。 <code>Android</code> 默认所有的非虚拟显示都是安全的。</p>
</li>
<li><p><code>appVsyncOffset, presentationDeadline</code><br>  这两个都和 <code>Vsync</code> 有关； <code>appVsyncOffset</code> 是一个偏移量，在系统或硬件 <code>Vsync</code> 的基础上做一些偏移； <code>presentationDeadline</code> 表示，一帧数据必现在这个时间内显示出来。</p>
</li>
</ul>
<h2 id="libgui-库"><a href="#libgui-库" class="headerlink" title="libgui 库"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#libgui-%E5%BA%93" title="libgui 库"></a><code>libgui</code> 库</h2><h3 id="代码目录结构-1"><a href="#代码目录结构-1" class="headerlink" title="代码目录结构"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-1" title="代码目录结构"></a>代码目录结构</h3><p><code>frameworks/native/libs/gui</code> 目录结构：</p>
<p>gui&#x2F;<br>├── Android.bp<br>├── BitTube.cpp<br>├── BufferItemConsumer.cpp<br>├── BufferItem.cpp<br>├── bufferqueue<br>│   └── 1.0<br>│       ├── B2HProducerListener.cpp<br>│       └── H2BGraphicBufferProducer.cpp<br>├── BufferQueueConsumer.cpp<br>├── BufferQueueCore.cpp<br>├── BufferQueue.cpp<br>├── BufferQueueProducer.cpp<br>├── BufferSlot.cpp<br>├── CleanSpec.mk<br>├── ConsumerBase.cpp<br>├── CpuConsumer.cpp<br>├── DisplayEventReceiver.cpp<br>├── FrameTimestamps.cpp<br>├── GLConsumer.cpp<br>├── GuiConfig.cpp<br>├── IConsumerListener.cpp<br>├── IDisplayEventConnection.cpp<br>├── IGraphicBufferConsumer.cpp<br>├── IGraphicBufferProducer.cpp<br>├── include<br>│   ├── gui<br>│   │   ├── BufferItemConsumer.h<br>│   │   ├── BufferItem.h<br>│   │   ├── bufferqueue<br>│   │   │   └── 1.0<br>│   │   │       ├── B2HProducerListener.h<br>│   │   │       └── H2BGraphicBufferProducer.h<br>│   │   ├── BufferQueueConsumer.h<br>│   │   ├── BufferQueueCore.h<br>│   │   ├── BufferQueueDefs.h<br>│   │   ├── BufferQueue.h<br>│   │   ├── BufferQueueProducer.h<br>│   │   ├── BufferSlot.h<br>│   │   ├── ConsumerBase.h<br>│   │   ├── CpuConsumer.h<br>│   │   ├── DisplayEventReceiver.h<br>│   │   ├── FrameTimestamps.h<br>│   │   ├── GLConsumer.h<br>│   │   ├── GuiConfig.h<br>│   │   ├── IConsumerListener.h<br>│   │   ├── IDisplayEventConnection.h<br>│   │   ├── IGraphicBufferConsumer.h<br>│   │   ├── IGraphicBufferProducer.h<br>│   │   ├── IProducerListener.h<br>│   │   ├── ISurfaceComposerClient.h<br>│   │   ├── ISurfaceComposer.h<br>│   │   ├── OccupancyTracker.h<br>│   │   ├── StreamSplitter.h<br>│   │   ├── SurfaceComposerClient.h<br>│   │   ├── SurfaceControl.h<br>│   │   ├── Surface.h<br>│   │   └── view<br>│   │       └── Surface.h<br>│   └── private<br>│       └── gui<br>│           ├── BitTube.h<br>│           ├── ComposerService.h<br>│           ├── LayerState.h<br>│           └── SyncFeatures.h<br>├── IProducerListener.cpp<br>├── ISurfaceComposerClient.cpp<br>├── ISurfaceComposer.cpp<br>├── LayerState.cpp<br>├── OccupancyTracker.cpp<br>├── StreamSplitter.cpp<br>├── SurfaceComposerClient.cpp<br>├── SurfaceControl.cpp<br>├── Surface.cpp<br>├── SyncFeatures.cpp<br>├── tests<br>│   ├── …<br>└── view<br>    └── Surface.cpp</p>
<p>11 directories, 96 files</p>
<p>其中 <code>H2B, B2H</code> 表示 <code>Framework Buffer</code> 和 <code>HAL</code> 层数据结构的相互转换；实际上代表的是同一样东西，方便各层内部使用。</p>
<h3 id="IGraphicBufferProducer-IProducerListener-生产者"><a href="#IGraphicBufferProducer-IProducerListener-生产者" class="headerlink" title="IGraphicBufferProducer/IProducerListener 生产者"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#IGraphicBufferProducer-IProducerListener-%E7%94%9F%E4%BA%A7%E8%80%85" title="IGraphicBufferProducer/IProducerListener 生产者"></a><code>IGraphicBufferProducer/IProducerListener</code> 生产者</h3><p><code>IGraphicBufferProducer</code> 是生产者接口，实现了 <code>IInterface</code> 可以用于跨进程通信。</p>
<p>&#x2F;&#x2F; IGraphicBufferProducer.h<br>class IGraphicBufferProducer : public IInterface<br>{<br>public:<br>    DECLARE_HYBRID_META_INTERFACE(GraphicBufferProducer,<br>        HGraphicBufferProducer)<br>    …<br>    &#x2F;&#x2F; 根据指定参数申请一块 Buffer ，索引值为 slot ，同步为 fence<br>    &#x2F;&#x2F; 从 BufferQueue 中出队一块缓存 GraphicBuffer<br>    virtual status_t dequeueBuffer(int* slot, sp<Fence>* fence,<br>        uint32_t w, uint32_t h,<br>        PixelFormat format, uint64_t usage, uint64_t* outBufferAge,<br>        FrameEventHistoryDelta* outTimestamps) &#x3D; 0;<br>    &#x2F;&#x2F; 获取 slot 位置的 GraphicBuffer<br>    virtual status_t requestBuffer(int slot, sp<GraphicBuffer>* buf) &#x3D; 0;<br>    &#x2F;&#x2F; 客户端已经向 slot 位置的 Buffer 填充完数据<br>    &#x2F;&#x2F; IGraphicBufferProducer 得到 Buffer 的输入信息，<br>    &#x2F;&#x2F; slot 这块缓存 GraphicBuffer 进入队列 BufferQueue<br>    virtual status_t queueBuffer(int slot, const QueueBufferInput&amp; input,<br>            QueueBufferOutput* output) &#x3D; 0;<br>    &#x2F;&#x2F; 释放 slot 位置的 GraphicBuffer<br>    virtual status_t detachBuffer(int slot) &#x3D; 0;<br>    virtual status_t detachNextBuffer(sp<GraphicBuffer>* outBuffer,<br>            sp<Fence>* outFence) &#x3D; 0;<br>    &#x2F;&#x2F; 根据指定的 buffer 获取 slot<br>    virtual status_t attachBuffer(int* outSlot,<br>            const sp<GraphicBuffer>&amp; buffer) &#x3D; 0;<br>    &#x2F;&#x2F; 释放 slot 位置的 buffer<br>    virtual status_t cancelBuffer(int slot, const sp<Fence>&amp; fence) &#x3D; 0;<br>    …<br>    &#x2F;&#x2F; 客户端根据 api 类型，连接 IGraphicBufferProducer ，<br>    &#x2F;&#x2F; 客户端得到缓存的相关信息 QueueBufferOutput<br>    virtual status_t connect(const sp<IProducerListener>&amp; listener,<br>            int api, bool producerControlledByApp,<br>            QueueBufferOutput* output) &#x3D; 0;<br>    &#x2F;&#x2F; 断开连接<br>    virtual status_t disconnect(int api,<br>        DisconnectMode mode &#x3D; DisconnectMode::Api) &#x3D; 0;<br>    &#x2F;&#x2F; 获取消费者名称<br>    virtual String8 getConsumerName() const &#x3D; 0;<br>    …<br>};</p>
<p><code>IProducerListener</code> 是 <code>IGraphicBufferProducer</code> 对应的回调接口。</p>
<p>&#x2F;&#x2F; IProducerListener.h<br>class ProducerListener : public virtual RefBase<br>{<br>public:<br>    ProducerListener() {}<br>    virtual ~ProducerListener();</p>
<pre><code>virtual void onBufferReleased() = 0; // Asynchronous
virtual bool needsReleaseNotify() = 0;
</code></pre>
<p>};</p>
<p>class IProducerListener : public ProducerListener, public IInterface<br>{<br>public:<br>    DECLARE_META_INTERFACE(ProducerListener)<br>};</p>
<p>class BnProducerListener : public BnInterface<IProducerListener><br>{<br>public:<br>    virtual status_t onTransact(uint32_t code, const Parcel&amp; data,<br>            Parcel* reply, uint32_t flags &#x3D; 0);<br>    virtual bool needsReleaseNotify();<br>};</p>
<p>class DummyProducerListener : public BnProducerListener<br>{<br>public:<br>    virtual ~DummyProducerListener();<br>    virtual void onBufferReleased() {}<br>    virtual bool needsReleaseNotify() { return false; }<br>};</p>
<h3 id="IGraphicBufferConsumer-IConsumerListener-消费者"><a href="#IGraphicBufferConsumer-IConsumerListener-消费者" class="headerlink" title="IGraphicBufferConsumer/IConsumerListener 消费者"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#IGraphicBufferConsumer-IConsumerListener-%E6%B6%88%E8%B4%B9%E8%80%85" title="IGraphicBufferConsumer/IConsumerListener 消费者"></a><code>IGraphicBufferConsumer/IConsumerListener</code> 消费者</h3><p><code>IGraphicBufferConsumer</code> 是消费者接口，实现了 <code>IInterface</code> 可以用于跨进程通信。</p>
<p>&#x2F;&#x2F; IGraphicBufferConsumer.h<br>class IGraphicBufferConsumer : public IInterface {<br>public:<br>    DECLARE_META_INTERFACE(GraphicBufferConsumer)<br>    …<br>    &#x2F;&#x2F; 从 BufferQueue 中获取一块准备好了的缓存 GraphicBuffer<br>    virtual status_t acquireBuffer(BufferItem* buffer,<br>        nsecs_t presentWhen, uint64_t maxFrameNumber &#x3D; 0) &#x3D; 0;<br>    &#x2F;&#x2F; 释放 slot 位置的缓存<br>    virtual status_t detachBuffer(int slot) &#x3D; 0;<br>    &#x2F;&#x2F; 根据指定的 GraphicBuffer 获取 slot<br>    virtual status_t attachBuffer(int* outSlot,<br>        const sp<GraphicBuffer>&amp; buffer) &#x3D; 0;<br>    &#x2F;&#x2F; 移除指定 slot 位置的缓存<br>    virtual status_t releaseBuffer(int buf, uint64_t frameNumber,<br>        EGLDisplay display, EGLSyncKHR fence,<br>        const sp<Fence>&amp; releaseFence) &#x3D; 0;<br>    …<br>    &#x2F;&#x2F; 连接一个消费者进入 BufferQueue<br>    virtual status_t consumerConnect(const sp<IConsumerListener>&amp; consumer,<br>                                     bool controlledByApp) &#x3D; 0;<br>    &#x2F;&#x2F; 从 BufferQueue 断开连接<br>    virtual status_t consumerDisconnect() &#x3D; 0;<br>    …<br>};</p>
<p><code>IConsumerListener</code> 是 <code>IGraphicBufferConsumer</code> 对应的回调接口：</p>
<p>&#x2F;&#x2F; IConsumerListener.h<br>class ConsumerListener : public virtual RefBase {<br>public:<br>    ConsumerListener() {}<br>    virtual ~ConsumerListener();</p>
<pre><code>virtual void onDisconnect() &#123;&#125; /* Asynchronous */
virtual void onFrameAvailable(const BufferItem&amp; item) 
    = 0; /* Asynchronous */
virtual void onFrameReplaced(const BufferItem&amp; /* item */)
    &#123;&#125; /* Asynchronous */
virtual void onBuffersReleased() = 0; /* Asynchronous */
virtual void onSidebandStreamChanged() = 0; /* Asynchronous */
virtual void addAndGetFrameTimestamps(const NewFrameEventsEntry* 
    /*newTimestamps*/, FrameEventHistoryDelta* /*outDelta*/) &#123;&#125;
</code></pre>
<p>};</p>
<p>class IConsumerListener : public ConsumerListener, public IInterface {<br>public:<br>    DECLARE_META_INTERFACE(ConsumerListener)<br>};</p>
<h3 id="BufferItem"><a href="#BufferItem" class="headerlink" title="BufferItem"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#BufferItem" title="BufferItem"></a><code>BufferItem</code></h3><p><code>BufferItem</code> 描述了一块缓存 <code>GraphicBuffer</code> ，以及位置 <code>mSlot</code> ，同步 <code>mFence</code> 等等信息。</p>
<p>&#x2F;&#x2F; BufferItem.h<br>class BufferItem : public Flattenable<BufferItem> {<br>    …<br>    sp<GraphicBuffer> mGraphicBuffer;<br>    sp<Fence> mFence;<br>    Rect mCrop;<br>    …<br>    android_dataspace mDataSpace;<br>    uint64_t mFrameNumber;<br>    int mSlot;<br>    …<br>}</p>
<h3 id="BufferSlot"><a href="#BufferSlot" class="headerlink" title="BufferSlot"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#BufferSlot" title="BufferSlot"></a><code>BufferSlot</code></h3><p><code>BufferSlot</code> 记录了当前 <code>slot</code> 位置的缓存 <code>GraphicBuffer</code> ，以及对应状态， <code>EGL</code> 相关信息。</p>
<p>&#x2F;&#x2F; BufferSlot.h<br>struct BufferSlot {</p>
<pre><code>BufferSlot()
: mGraphicBuffer(nullptr),
  mEglDisplay(EGL_NO_DISPLAY),
  mBufferState(),
  mRequestBufferCalled(false),
  mFrameNumber(0),
  mEglFence(EGL_NO_SYNC_KHR),
  mFence(Fence::NO_FENCE),
  mAcquireCalled(false),
  mNeedsReallocation(false) &#123;
&#125;

sp&lt;GraphicBuffer&gt; mGraphicBuffer;
EGLDisplay mEglDisplay;
BufferState mBufferState;
bool mRequestBufferCalled;
uint64_t mFrameNumber;
EGLSyncKHR mEglFence;
sp&lt;Fence&gt; mFence;
bool mAcquireCalled;
bool mNeedsReallocation;
</code></pre>
<p>};</p>
<p><code>BufferQueueDefs</code> 中定义了一个 <code>BufferSlot</code> 的数组结构类型 <code>SlotsType</code> 。</p>
<p>&#x2F;&#x2F; BufferQueueDefs.h<br>namespace android {<br>    class BufferQueueCore;</p>
<pre><code>namespace BufferQueueDefs &#123;
    typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS];
&#125; // namespace BufferQueueDefs
</code></pre>
<p>} &#x2F;&#x2F; namespace android</p>
<h3 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#BufferQueueCore" title="BufferQueueCore"></a><code>BufferQueueCore</code></h3><p><code>BufferQueueCore</code> 是生产者消费模型的核心，如下是几个重要的成员变量：</p>
<p>&#x2F;&#x2F; BufferQueueCore.h<br>class BufferQueueCore : public virtual RefBase {<br>public:<br>    …<br>    typedef Vector<BufferItem> Fifo;<br>private:<br>    …<br>    String8 mConsumerName;<br>    sp<IConsumerListener> mConsumerListener;<br>    sp<IProducerListener> mConnectedProducerListener;</p>
<pre><code>BufferQueueDefs::SlotsType mSlots;
Fifo mQueue;
...
</code></pre>
<p>}</p>
<ul>
<li><code>mQueue</code><br>  是一个新建先出队列，存储了一队 <code>BufferItem</code> 数据，即一组缓存区。</li>
<li><code>mSlots</code><br>  一个数组，保存了 <code>BufferSlot</code> 数据，每个 <code>slot</code> 位置对应一个缓存。</li>
<li><code>mConsumerListener</code><br>  当前生产消费模型中的，消费者回调接口。</li>
<li><code>mConnectedProducerListener</code><br>  当前生产消费模型中的，生产者回调接口。</li>
</ul>
<h3 id="BufferQueueProducer-BufferQueueConsumer-生产者-消费者实现类"><a href="#BufferQueueProducer-BufferQueueConsumer-生产者-消费者实现类" class="headerlink" title="BufferQueueProducer/BufferQueueConsumer 生产者 &#x2F; 消费者实现类"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#BufferQueueProducer-BufferQueueConsumer-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E7%8E%B0%E7%B1%BB" title="BufferQueueProducer/BufferQueueConsumer 生产者/消费者实现类"></a><code>BufferQueueProducer/BufferQueueConsumer</code> 生产者 &#x2F; 消费者实现类</h3><p><code>BufferQueueProducer</code> 是 <code>IGraphicBufferConsumer</code> 的实现类，实现了生产者对应的功能。</p>
<p>&#x2F;&#x2F; BufferQueueProducer.h<br>class BufferQueueProducer : public BnGraphicBufferProducer,<br>                            private IBinder::DeathRecipient {<br>    …<br>private:<br>    …<br>    sp<BufferQueueCore> mCore;<br>    &#x2F;&#x2F; This references mCore-&gt;mSlots.<br>    BufferQueueDefs::SlotsType&amp; mSlots;<br>    String8 mConsumerName;<br>    …<br>    sp<Fence> mLastQueueBufferFence;<br>    Rect mLastQueuedCrop;<br>    uint32_t mLastQueuedTransform;<br>}</p>
<p><code>BufferQueueProducer</code> 中持有 <code>BufferQueueCore</code> 对象； <code>mSlots</code> 指向 <code>mCore-&gt;mSlots</code> ；同时保持了生产消费模型中，对应消费者的名称。</p>
<p><code>BufferQueueConsumer</code> 是 <code>IGraphicBufferConsumer</code> 的实现类，实现了消费者对应的功能。</p>
<p>&#x2F;&#x2F; BufferQueueConsumer.h<br>class BufferQueueConsumer : public BnGraphicBufferConsumer {<br>    …<br>private:<br>    sp<BufferQueueCore> mCore;<br>    &#x2F;&#x2F; This references mCore-&gt;mSlots.<br>    BufferQueueDefs::SlotsType&amp; mSlots;<br>    String8 mConsumerName;<br>}</p>
<p><code>BufferQueueConsumer</code> 中持有 <code>BufferQueueCore</code> 对象； <code>mSlots</code> 指向 <code>mCore-&gt;mSlots</code> 。</p>
<h3 id="BufferQueue-模型"><a href="#BufferQueue-模型" class="headerlink" title="BufferQueue 模型"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#BufferQueue-%E6%A8%A1%E5%9E%8B" title="BufferQueue 模型"></a><code>BufferQueue</code> 模型</h3><p><code>BufferQueue</code> 类是 <code>Android</code> 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产者）连接到接受数据以进行显示或进一步处理的一方（消费者）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 <code>BufferQueue</code> 。<br>基本用法很简单：生产者请求一个可用的缓冲区 <code>dequeueBuffer</code> ，并指定一组特性，包括宽度、高度、像素格式和用法标记；生产者填充缓冲区并将其返回到队列 <code>queueBuffer</code> 。随后消费者获取该缓冲区 <code>acquireBuffer</code> ，并使用该缓冲区的内容。当消费者操作完毕后，将该缓冲区返回到队列 <code>releaseBuffer</code> 。<br>最新的 Android 设备支持 “同步框架”，这使得系统能够在与可以异步处理图形数据的硬件组件结合使用时提高工作效率。例如，生产者可以提交一系列 <code>OpenGL ES</code> 绘制命令，然后在渲染完成之前将输出缓冲区加入队列。该缓冲区伴有一个栅栏，当内容准备就绪时，栅栏会发出信号。当该缓冲区返回到空闲列表时，会伴有第二个栅栏，因此消费者可以在内容仍在使用期间释放该缓冲区。该方法缩短了缓冲区通过系统时的延迟时间，并提高了吞吐量。<br>队列的一些特性（例如可以容纳的最大缓冲区数）由生产者和消费者联合决定。但是 <code>BufferQueue</code> 负责根据需要分配缓冲区。除非特性发生变化，否则将会保留缓冲区；例如，如果生产者请求具有不同大小的缓冲区，则系统会释放旧的缓冲区，并根据需要分配新的缓冲区。<br>生产者和消费者可以存在于不同的进程中； <code>BufferQueue</code> 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作），缓冲区始终通过句柄进行传递。</p>
<p>&#x2F;&#x2F; BufferQueue.h<br>class BufferQueue {<br>public:<br>    …<br>    typedef ::android::ConsumerListener ConsumerListener;</p>
<pre><code>// ProxyConsumerListener 是 ConsumerListener 弱引用实现
class ProxyConsumerListener : public BnConsumerListener &#123;
public:
    explicit ProxyConsumerListener(const wp&lt;ConsumerListener&gt;&amp; 
        consumerListener);
    ~ProxyConsumerListener() override;
    void onDisconnect() override;
    void onFrameAvailable(const BufferItem&amp; item) override;
    void onFrameReplaced(const BufferItem&amp; item) override;
    void onBuffersReleased() override;
    void onSidebandStreamChanged() override;
    void addAndGetFrameTimestamps(
            const NewFrameEventsEntry* newTimestamps,
            FrameEventHistoryDelta* outDelta) override;
private:
    // 弱引用
    wp&lt;ConsumerListener&gt; mConsumerListener;
&#125;;

// BufferQueue manages a pool of gralloc memory slots to be used by
// producers and consumers. allocator is used to allocate all the
// needed gralloc buffers.
static void createBufferQueue(
        sp&lt;IGraphicBufferProducer&gt;* outProducer,
        sp&lt;IGraphicBufferConsumer&gt;* outConsumer,
        bool consumerIsSurfaceFlinger = false);

BufferQueue() = delete; // Create through createBufferQueue
</code></pre>
<p>};</p>
<p><code>BufferQueue</code> 的头文件定义很简单：</p>
<ul>
<li>定义了一个 <code>ConsumerListener</code> 的弱引用</li>
<li>整个类只有一个函数 <code>createBufferQueue</code> ，它将参数中的 <code>IGraphicBufferProducer, IGraphicBufferConsumer</code> 消费者关联起来</li>
<li>没有构造函数，只能通过 <code>createBufferQueue</code> 来创建对象</li>
<li><code>BufferQueue</code> 中并不包含队列数据结构来存储缓存，仅仅连接了生产者、消费者两者的关系</li>
</ul>
<p>来看 <code>createBufferQueue</code> 的具体实现：</p>
<p>&#x2F;&#x2F; BufferQueue.cp<br>void BufferQueue::createBufferQueue(<br>        sp<IGraphicBufferProducer>* outProducer,<br>        sp<IGraphicBufferConsumer>* outConsumer,<br>        bool consumerIsSurfaceFlinger) {<br>    …<br>    sp<BufferQueueCore> core(new BufferQueueCore());<br>    sp<IGraphicBufferProducer> producer(<br>        new BufferQueueProducer(core, consumerIsSurfaceFlinger));<br>    …<br>    sp<IGraphicBufferConsumer> consumer(new BufferQueueConsumer(core));<br>    …<br>    *outProducer &#x3D; producer;<br>    *outConsumer &#x3D; consumer;<br>}</p>
<p>上面代码删掉了 <code>LOG</code> 打印及空判断，整个代码流程非常简单：</p>
<ul>
<li>新建 <code>BufferQueueCore core</code></li>
<li>由 <code>core</code> 新建生产者 <code>IGraphicBufferProducer</code></li>
<li>由 <code>core</code> 新建消费者 <code>IGraphicBufferConsumer</code></li>
</ul>
<p>也就是说 <code>BufferQueueCore</code> 是最终的纽带，保存了生产者消费者对应的缓存区，连接了两者的关系。</p>
<h3 id="Surface-1"><a href="#Surface-1" class="headerlink" title="Surface"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#Surface-1" title="Surface"></a><code>Surface</code></h3><p><code>Surface</code> 代表着窗口，它包含一个生产者 <code>IGraphicBufferProducer</code> 用来填充缓存，也就是窗口中用来显示在屏幕上的内容，<code>mSlot</code> 数组表示可以有多个缓存区。</p>
<p>&#x2F;&#x2F; Surface.h<br>class Surface<br>    : public ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;<br>{<br>public:<br>    …<br>    sp<IGraphicBufferProducer> getIGraphicBufferProducer() const;<br>    String8 getConsumerName() const;<br>    …<br>protected:<br>    …<br>    struct BufferSlot {<br>        sp<GraphicBuffer> buffer;<br>        Region dirtyRegion;<br>    };<br>    sp<IGraphicBufferProducer> mGraphicBufferProducer;<br>    BufferSlot mSlots[NUM_BUFFER_SLOTS];<br>    uint32_t mReqWidth;<br>    uint32_t mReqHeight;<br>    PixelFormat mReqFormat;<br>    …<br>    &#x2F;&#x2F; must be used from the lock&#x2F;unlock thread<br>    sp<GraphicBuffer>           mLockedBuffer;<br>    sp<GraphicBuffer>           mPostedBuffer;<br>    …<br>private:<br>    …<br>}</p>
<h3 id="ISurfaceComposer-ISurfaceComposerClient"><a href="#ISurfaceComposer-ISurfaceComposerClient" class="headerlink" title="ISurfaceComposer/ISurfaceComposerClient"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#ISurfaceComposer-ISurfaceComposerClient" title="ISurfaceComposer/ISurfaceComposerClient"></a><code>ISurfaceComposer/ISurfaceComposerClient</code></h3><p><code>ISurfaceComposerClient/ISurfaceComposer</code> 都继承了 <code>IInterface</code> ，它们俩分别代表 <code>Surface</code> 合成的客户端和服务端，具体在 <code>SurfaceFlinger</code> 服务进程中实现， <code>libgui</code> 中只对合成能力（函数）做了定义。</p>
<p>&#x2F;&#x2F; ISurfaceComposerClient.h<br>class ISurfaceComposerClient : public IInterface {<br>public:<br>    DECLARE_META_INTERFACE(SurfaceComposerClient)<br>    …<br>    virtual status_t createSurface(const String8&amp; name, uint32_t w,<br>        uint32_t h, PixelFormat format, uint32_t flags,<br>        const sp<IBinder>&amp; parent, uint32_t windowType,<br>        uint32_t ownerUid, sp<IBinder>* handle,<br>        sp<IGraphicBufferProducer>* gbp) &#x3D; 0;<br>    virtual status_t destroySurface(const sp<IBinder>&amp; handle) &#x3D; 0;<br>    virtual status_t clearLayerFrameStats(const sp<IBinder>&amp; handle)<br>        const &#x3D; 0;<br>    virtual status_t getLayerFrameStats(const sp<IBinder>&amp; handle,<br>        FrameStats* outStats) const &#x3D; 0;<br>};</p>
<p>&#x2F;&#x2F; ISurfaceComposer.h<br>class ISurfaceComposer: public IInterface {<br>public:<br>    DECLARE_META_INTERFACE(SurfaceComposer)<br>    …<br>    virtual sp<ISurfaceComposerClient> createConnection() &#x3D; 0;<br>    virtual sp<ISurfaceComposerClient> createScopedConnection(<br>            const sp<IGraphicBufferProducer>&amp; parent) &#x3D; 0;<br>    virtual sp<IDisplayEventConnection> createDisplayEventConnection(<br>            VsyncSource vsyncSource &#x3D; eVsyncSourceApp) &#x3D; 0;<br>    virtual sp<IBinder> createDisplay(const String8&amp; displayName,<br>            bool secure) &#x3D; 0;<br>    virtual void destroyDisplay(const sp<IBinder>&amp; display) &#x3D; 0;<br>    …<br>    virtual status_t captureScreen(const sp<IBinder>&amp; display,<br>            const sp<IGraphicBufferProducer>&amp; producer,<br>            Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,<br>            int32_t minLayerZ, int32_t maxLayerZ,<br>            bool useIdentityTransform,<br>            Rotation rotation &#x3D; eRotateNone) &#x3D; 0;<br>}</p>
<p>如下是 <code>ISurfaceComposerClient</code> 相关的类图结构：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/01113-android-graphics-display-ISurfaceComposerClient.png"></p>
<p>先看 <code>ComposerService</code> ，它代表着 <code>SurfaceFlinger</code> 服务端，头文件定义如下：</p>
<p>&#x2F;&#x2F; ComposerService.h<br>class ComposerService : public Singleton<ComposerService><br>{<br>    sp<ISurfaceComposer> mComposerService;<br>    sp<a href="IBinder::DeathRecipient">IBinder::DeathRecipient</a> mDeathObserver;<br>    Mutex mLock;</p>
<pre><code>ComposerService();
void connectLocked();
void composerServiceDied();
friend class Singleton&lt;ComposerService&gt;;
</code></pre>
<p>public:</p>
<pre><code>// Get a connection to the Composer Service.  This will block until
// a connection is established.
static sp&lt;ISurfaceComposer&gt; getComposerService();
</code></pre>
<p>};</p>
<p>查看 <code>connectLocked, getComposerService</code> 两个函数的实现：</p>
<p>&#x2F;&#x2F; SurfaceComposerClient.cpp<br>void ComposerService::connectLocked() {<br>    const String16 name(“SurfaceFlinger”);<br>    while (getService(name, &amp;mComposerService) !&#x3D; NO_ERROR) {<br>        usleep(250000);<br>    }<br>    assert(mComposerService !&#x3D; NULL);<br>    …<br>}</p>
<p>&#x2F;<em>static</em>&#x2F; sp<ISurfaceComposer> ComposerService::getComposerService() {<br>    ComposerService&amp; instance &#x3D; ComposerService::getInstance();<br>    Mutex::Autolock _l(instance.mLock);<br>    if (instance.mComposerService &#x3D;&#x3D; NULL) {<br>        ComposerService::getInstance().connectLocked();<br>        assert(instance.mComposerService !&#x3D; NULL);<br>        ALOGD(“ComposerService reconnected”);<br>    }<br>    return instance.mComposerService;<br>}</p>
<p><code>connectLocked</code> 连接过程就是等待 <code>SurfaceFlinger</code> 服务启动后并获取它； <code>getComposerService</code> 直接返回已经连接成功的实例 <code>mComposerService</code> 。</p>
<p>再看 <code>SurfaceComposerClient</code> ，可以将它理解为应用端，是 <code>SurfaceFlinger</code> 服务的客户端，它将建立和 <code>SurfaceFlinger</code> 服务的通信，头文件定义如下：</p>
<p>&#x2F;&#x2F; SurfaceComposerClient.h<br>class SurfaceComposerClient : public RefBase<br>{<br>public:<br>    &#x2F;&#x2F; Return the connection of this client<br>    sp<IBinder> connection() const;<br>    …<br>    &#x2F;&#x2F;! Create a surface<br>    sp<SurfaceControl> createSurface(<br>            const String8&amp; name,&#x2F;&#x2F; name of the surface<br>            uint32_t w,         &#x2F;&#x2F; width in pixel<br>            uint32_t h,         &#x2F;&#x2F; height in pixel<br>            PixelFormat format, &#x2F;&#x2F; pixel-format desired<br>            uint32_t flags &#x3D; 0, &#x2F;&#x2F; usage flags<br>            SurfaceControl* parent &#x3D; nullptr, &#x2F;&#x2F; parent<br>            uint32_t windowType &#x3D; 0,<br>            uint32_t ownerUid &#x3D; 0 &#x2F;&#x2F; UID of the task<br>    );<br>    status_t    destroySurface(const sp<IBinder>&amp; id);</p>
<pre><code>//! Create a virtual display
static sp&lt;IBinder&gt; createDisplay(const String8&amp; displayName,
    bool secure);
//! Destroy a virtual display
static void destroyDisplay(const sp&lt;IBinder&gt;&amp; display);
...
</code></pre>
<p>private:<br>    virtual void onFirstRef();<br>    Composer&amp; getComposer();<br>    …<br>    sp<ISurfaceComposerClient>  mClient;<br>    Composer&amp;                   mComposer;<br>    wp<IGraphicBufferProducer>  mParent;<br>};</p>
<p><code>mClient</code> 实际对应的是 <code>SurfaceFlinger</code> 进程中的 <code>Client.cpp</code> ，查看 <code>SurfaceComposerClient::onFirstRef</code> 源码：</p>
<p>&#x2F;&#x2F; SurfaceComposerClient.cpp<br>void SurfaceComposerClient::onFirstRef() {<br>    sp<ISurfaceComposer> sm(ComposerService::getComposerService());<br>    if (sm !&#x3D; 0) {<br>        auto rootProducer &#x3D; mParent.promote();<br>        sp<ISurfaceComposerClient> conn;<br>        conn &#x3D; (rootProducer !&#x3D; nullptr) ?<br>                sm-&gt;createScopedConnection(rootProducer) :<br>                sm-&gt;createConnection();<br>        if (conn !&#x3D; 0) {<br>            mClient &#x3D; conn;<br>            mStatus &#x3D; NO_ERROR;<br>        }<br>    }<br>}</p>
<p>&#x2F;&#x2F; SurfaceFlinger.cpp<br>sp<ISurfaceComposerClient> SurfaceFlinger::createScopedConnection(<br>        const sp<IGraphicBufferProducer>&amp; gbp) {<br>    if (authenticateSurfaceTexture(gbp) &#x3D;&#x3D; false) {<br>        return nullptr;<br>    }<br>    const auto&amp; layer &#x3D; (static_cast&lt;MonitoredProducer*&gt;(<br>        gbp.get()))-&gt;getLayer();<br>    if (layer &#x3D;&#x3D; nullptr) {<br>        return nullptr;<br>    }</p>
<p>   return initClient(new Client(this, layer));<br>}</p>
<p><code>SurfaceComposerClient</code> 中有一个重要功能就是创建 <code>Surface</code> ，对应源码：</p>
<p>&#x2F;&#x2F; SurfaceComposerClient.cpp<br>sp<SurfaceControl> SurfaceComposerClient::createSurface(<br>        const String8&amp; name,<br>        uint32_t w,<br>        uint32_t h,<br>        PixelFormat format,<br>        uint32_t flags,<br>        SurfaceControl* parent,<br>        uint32_t windowType,<br>        uint32_t ownerUid)<br>{<br>    sp<SurfaceControl> sur;<br>    if (mStatus &#x3D;&#x3D; NO_ERROR) {<br>        sp<IBinder> handle;<br>        sp<IBinder> parentHandle;<br>        sp<IGraphicBufferProducer> gbp;</p>
<pre><code>    if (parent != nullptr) &#123;
        parentHandle = parent-&gt;getHandle();
    &#125;
    status_t err = mClient-&gt;createSurface(name, w, h, format, 
            flags, parentHandle,
            windowType, ownerUid, &amp;handle, &amp;gbp);
    ALOGE_IF(err, &quot;SurfaceComposerClient::createSurface error..&quot;);
    if (err == NO_ERROR) &#123;
        sur = new SurfaceControl(this, handle, gbp);
    &#125;
&#125;
return sur;
</code></pre>
<p>}</p>
<p>最终会调用 <code>SurfaceFlinger</code> 中的 <code>mClient</code> 来创建 <code>Layer, IGraphicBufferProducer</code> ；而具体的 <code>Surface</code> 则由 <code>SurfaceControl</code> 来创建。</p>
<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#SurfaceControl" title="SurfaceControl"></a><code>SurfaceControl</code></h3><p><code>SurfaceControl</code> 持有创建的 <code>Surface</code> 的强引用，头文件定义：</p>
<p>&#x2F;&#x2F; SurfaceControl.h<br>class SurfaceControl : public RefBase<br>{<br>    …<br>private:<br>    …<br>    sp<SurfaceComposerClient>   mClient;<br>    sp<IBinder>                 mHandle;<br>    sp<IGraphicBufferProducer>  mGraphicBufferProducer;<br>    mutable sp<Surface>         mSurfaceData;<br>};<br>}</p>
<p><code>mHandle</code> 指向 <code>SurfaceFlinger</code> 创建的 <code>Layer</code> 。而 <code>SurfaceControl::createSurface</code> 直接 <code>new</code> 了一个 <code>Surface</code> 对象。</p>
<p>&#x2F;&#x2F; SurfaceControl.cpp<br>sp<Surface> SurfaceControl::generateSurfaceLocked() const<br>{<br>    &#x2F;&#x2F; This surface is always consumed by SurfaceFlinger, so the<br>    &#x2F;&#x2F; producerControlledByApp value doesn’t matter; using false.<br>    mSurfaceData &#x3D; new Surface(mGraphicBufferProducer, false);</p>
<pre><code>return mSurfaceData;
</code></pre>
<p>}</p>
<p>sp<Surface> SurfaceControl::createSurface() const<br>{<br>    Mutex::Autolock _l(mLock);<br>    return generateSurfaceLocked();<br>}</p>
<h3 id="IDisplayEventConnection-显示连接"><a href="#IDisplayEventConnection-显示连接" class="headerlink" title="IDisplayEventConnection 显示连接"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#IDisplayEventConnection-%E6%98%BE%E7%A4%BA%E8%BF%9E%E6%8E%A5" title="IDisplayEventConnection 显示连接"></a><code>IDisplayEventConnection</code> 显示连接</h3><p><code>IDisplayEventConnection</code> 继承了 <code>IInterface</code> ，客户端 <code>APP</code> 通过它向服务端 <code>SurfaceFlinger</code> 发送刷新请求。</p>
<p>class IDisplayEventConnection : public IInterface {<br>public:<br>    DECLARE_META_INTERFACE(DisplayEventConnection)</p>
<pre><code>/*
 * stealReceiveChannel() returns a BitTube to receive events from. 
 *Only the receive file descriptor of outChannel will be initialized,
 * and this effectively &quot;steals&quot; the receive channel from the remote
 * end (such that the remote end can only use its send channel).
 */
virtual status_t stealReceiveChannel(gui::BitTube* outChannel) = 0;

/*
 * setVsyncRate() sets the vsync event delivery rate. 
 * A value of 1 returns every vsync event.
 * A value of 2 returns every other event, etc. 
 * A value of 0 returns no event unless
 * requestNextVsync() has been called.
 */
virtual status_t setVsyncRate(uint32_t count) = 0;

/*
 * requestNextVsync() schedules the next vsync event. 
 * It has no effect if the vsync rate is &gt; 0.
 */
virtual void requestNextVsync() = 0; // Asynchronous
</code></pre>
<p>};</p>
<p><code>IDisplayEventConnection</code> 的类图结构</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-IDisplayEventConnection.png"></p>
<p><code>IDisplayEventConnection</code> 的具体实现是在 <code>SurfaceFlinger</code> 进程中的 <code>EventThread::Connection</code> ；<code>DisplayEventReceiver</code> 持有该实例。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%B0%8F%E7%BB%93-1" title="小结"></a>小结</h3><ul>
<li><code>libgui</code> 中一共提供了 4 组 <code>IInterface</code> 接口： <code>IGraphicBufferProducer/IProducerListener, IGraphicBufferConsumer/IConsumerListener, ISurfaceComposerClient/ISurfaceComposer, IDisplayEventConnection</code></li>
<li><code>IGraphicBufferProducer/IProducerListener</code> 生产者模型</li>
<li><code>IGraphicBufferConsumer/IConsumerListener</code> 消费者模型</li>
<li><code>ISurfaceComposerClient/ISurfaceComposer</code> 提供创建 <code>Surface</code> 的功能，及相关管理</li>
<li><code>IDisplayEventConnection</code> 提供了 <code>APP</code> 客户端请求服务端 <code>SurfaceFlinger</code> 刷新的接口</li>
</ul>
<h2 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#SurfaceFlinger" title="SurfaceFlinger"></a><code>SurfaceFlinger</code></h2><h3 id="代码速查表-1"><a href="#代码速查表-1" class="headerlink" title="代码速查表"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E4%BB%A3%E7%A0%81%E9%80%9F%E6%9F%A5%E8%A1%A8-1" title="代码速查表"></a>代码速查表</h3><p>surfaceflinger&#x2F;<br>├── Android.bp<br>├── Android.mk<br>├── Barrier.h<br>├── Client.cpp<br>├── Client.h<br>├── clz.h<br>├── Colorizer.h<br>├── DdmConnection.cpp<br>├── DdmConnection.h<br>├── DisplayDevice.cpp<br>├── DisplayDevice.h<br>├── DisplayHardware<br>│   ├── ComposerHal.cpp<br>│   ├── ComposerHal.h<br>│   ├── DisplaySurface.h<br>│   ├── FramebufferSurface.cpp<br>│   ├── FramebufferSurface.h<br>│   ├── HWC2.cpp<br>│   ├── HWC2.h<br>│   ├── HWComposerBufferCache.cpp<br>│   ├── HWComposerBufferCache.h<br>│   ├── HWComposer.cpp<br>│   ├── HWComposer.h<br>│   ├── HWComposer_hwc1.cpp<br>│   ├── HWComposer_hwc1.h<br>│   ├── PowerHAL.cpp<br>│   ├── PowerHAL.h<br>│   ├── VirtualDisplaySurface.cpp<br>│   └── VirtualDisplaySurface.h<br>├── DisplayUtils.cpp<br>├── DisplayUtils.h<br>├── DispSync.cpp<br>├── DispSync.h<br>├── Effects<br>│   ├── Daltonizer.cpp<br>│   └── Daltonizer.h<br>├── EventControlThread.cpp<br>├── EventControlThread.h<br>├── EventLog<br>│   ├── EventLog.cpp<br>│   ├── EventLog.h<br>│   └── EventLogTags.logtags<br>├── EventThread.cpp<br>├── EventThread.h<br>├── ExSurfaceFlinger<br>│   ├── ExLayer.cpp<br>│   ├── ExLayer.h<br>│   ├── ExSurfaceFlinger.cpp<br>│   ├── ExSurfaceFlinger.h<br>│   ├── ExVirtualDisplaySurface.cpp<br>│   └── ExVirtualDisplaySurface.h<br>├── FrameTracker.cpp<br>├── FrameTracker.h<br>├── GpuService.cpp<br>├── GpuService.h<br>├── Layer.cpp<br>├── LayerDim.cpp<br>├── LayerDim.h<br>├── Layer.h<br>├── LayerRejecter.cpp<br>├── LayerRejecter.h<br>├── LayerVector.cpp<br>├── LayerVector.h<br>├── main_surfaceflinger.cpp<br>├── MessageQueue.cpp<br>├── MessageQueue.h<br>├── MODULE_LICENSE_APACHE2<br>├── MonitoredProducer.cpp<br>├── MonitoredProducer.h<br>├── RenderEngine<br>│   ├── Description.cpp<br>│   ├── Description.h<br>│   ├── GLES20RenderEngine.cpp<br>│   ├── GLES20RenderEngine.h<br>│   ├── GLExtensions.cpp<br>│   ├── GLExtensions.h<br>│   ├── Mesh.cpp<br>│   ├── Mesh.h<br>│   ├── ProgramCache.cpp<br>│   ├── ProgramCache.h<br>│   ├── Program.cpp<br>│   ├── Program.h<br>│   ├── RenderEngine.cpp<br>│   ├── RenderEngine.h<br>│   ├── Texture.cpp<br>│   └── Texture.h<br>├── StartPropertySetThread.cpp<br>├── StartPropertySetThread.h<br>├── SurfaceFlingerConsumer.cpp<br>├── SurfaceFlingerConsumer.h<br>├── SurfaceFlinger.cpp<br>├── SurfaceFlinger.h<br>├── SurfaceFlinger_hwc1.cpp<br>├── surfaceflinger.rc<br>├── SurfaceInterceptor.cpp<br>├── SurfaceInterceptor.h<br>├── Transform.cpp<br>└── Transform.h</p>
<p>9 directories, 117 files</p>
<h3 id="surfaceflinger-进程"><a href="#surfaceflinger-进程" class="headerlink" title="surfaceflinger 进程"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#surfaceflinger-%E8%BF%9B%E7%A8%8B" title="surfaceflinger 进程"></a><code>surfaceflinger</code> 进程</h3><p><code>SurfaceFlinger</code> 是以独立进程运行的，进程名为 <code>surfaceflinger</code> ，对应的 <code>rc</code> 文件如下：</p>
<p>&#x2F;&#x2F; surfaceflinger.rc<br>service surfaceflinger &#x2F;system&#x2F;bin&#x2F;surfaceflinger<br>    class core animation<br>    user system<br>    group graphics drmrpc readproc<br>    onrestart restart zygote<br>    writepid &#x2F;dev&#x2F;stune&#x2F;foreground&#x2F;tasks<br>    socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0<br>    socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0<br>    socket pdx&#x2F;system&#x2F;vr&#x2F;display&#x2F;vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</p>
<p><code>surfaceflinger</code> 服务属于核心类 <code>core</code>，当 <code>surfaceflinger</code> 重启时会触发 <code>zygote</code> 的重启。接下来看进程 <code>main</code> 方法对应文件为：</p>
<p>&#x2F;&#x2F; main_surfaceflinger.cpp<br>int main(int, char**) {<br>    &#x2F;&#x2F; 启动 IAllocator, DisplayService 两个服务<br>    startHidlServices();</p>
<pre><code>signal(SIGPIPE, SIG_IGN);

ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);
sp&lt;ProcessState&gt; ps(ProcessState::self());
ps-&gt;startThreadPool();

// 1. new SurfaceFlinger 实例
sp&lt;SurfaceFlinger&gt; flinger = 
    DisplayUtils::getInstance()-&gt;getSFInstance();

setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);
set_sched_policy(0, SP_FOREGROUND);
if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM);

// 2. SurfaceFlinger 初始化
flinger-&gt;init();

// 3. 发布 SurfaceFlinger, GpuService 两个服务
// publish surface flinger
sp&lt;IServiceManager&gt; sm(defaultServiceManager());
sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), 
    flinger, false);

// publish GpuService
sp&lt;GpuService&gt; gpuservice = new GpuService();
sm-&gt;addService(String16(GpuService::SERVICE_NAME),gpuservice,false);

struct sched_param param = &#123;0&#125;;
param.sched_priority = 2;
if (sched_setscheduler(0, SCHED_FIFO, ¶m) != 0) &#123;
    ALOGE(&quot;Couldn&#39;t set SCHED_FIFO&quot;);
&#125;

// run surface flinger in this thread
// 4. SurfaceFlinger 无限循环等待事件
flinger-&gt;run();

return 0;
</code></pre>
<p>}</p>
<p><code>surfaceflinger</code> 进程的 <code>main</code> 函数中主要做了 4 件事：</p>
<ul>
<li>通过 <code>DisplayUtils</code> 创建 <code>SurfaceFlinger</code> 对象</li>
<li><code>SurfaceFlinger</code> 对象调用 <code>init</code> 方法，实现初始化</li>
<li><code>SurfaceFlinger</code> 向系统注册 <code>Binder</code> 服务</li>
<li><code>SurfaceFlinger</code> 对象调用 <code>run</code> 方法，该方法是一个 <code>do-while</code> 无限循环</li>
</ul>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B" title="初始化流程"></a>初始化流程</h3><p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/606437-92984e2a12a8b3d0.png">SurfaceFlinger 初始化流程，查看大图</a></p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-SurfaceFlinger-init.png"></p>
<h3 id="DisplayDevice-显示设备"><a href="#DisplayDevice-显示设备" class="headerlink" title="DisplayDevice 显示设备"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#DisplayDevice-%E6%98%BE%E7%A4%BA%E8%AE%BE%E5%A4%87" title="DisplayDevice 显示设备"></a><code>DisplayDevice</code> 显示设备</h3><p>&#x2F;&#x2F; DisplayDevice.h<br>class DisplayDevice : public LightRefBase<DisplayDevice><br>{<br>public:<br>    …<br>    enum DisplayType {<br>        DISPLAY_ID_INVALID &#x3D; -1,<br>        DISPLAY_PRIMARY     &#x3D; HWC_DISPLAY_PRIMARY,      &#x2F;&#x2F; 主显<br>        DISPLAY_EXTERNAL    &#x3D; HWC_DISPLAY_EXTERNAL,     &#x2F;&#x2F; 外显<br>        DISPLAY_VIRTUAL     &#x3D; HWC_DISPLAY_VIRTUAL,      &#x2F;&#x2F; 虚显<br>        NUM_BUILTIN_DISPLAY_TYPES &#x3D; HWC_NUM_PHYSICAL_DISPLAY_TYPES,<br>    };<br>    …<br>}</p>
<p>显示设备有三种类型：主显、外显、虚显；每添加一个显示屏，都会创建一个 <code>DisplayDevice</code> 。</p>
<h3 id="Layer-层"><a href="#Layer-层" class="headerlink" title="Layer 层"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#Layer-%E5%B1%82" title="Layer 层"></a><code>Layer</code> 层</h3><p><code>Layer</code> 是 <code>SurfaceFlinger</code> 进行合成的基本操作单元。<code>Layer</code> 在应用请求创建 <code>Surface</code> 的时候在 <code>SurfaceFlinger</code> 内部创建，因此一个 <code>Surface</code> 对应一个 <code>Layer</code> 。每个 <code>Layer</code> 包含常见属性：</p>
<ul>
<li><code>Z order</code></li>
<li><code>Alpha value from 0 to 255</code></li>
<li><code>visibleRegion</code></li>
<li><code>crop region</code></li>
<li><code>transformation: rotate 0, 90, 180, 270: flip H, V: scale</code></li>
</ul>
<p>当多个 <code>Layer</code> 进行合成的时候，并不是整个 <code>Layer</code> 的空间都会被完全显示，根据这个 <code>Layer</code> 最终的显示效果，一个 <code>Layer</code> 可以被划分成很多的 <code>Region</code> ， 在 <code>SurfaceFlinger</code> 中定义了以下几种类型：</p>
<ul>
<li><code>TransparantRegion</code> ：完全透明的区域，在它之下的区域将被显示出来</li>
<li><code>OpaqueRegion</code> ：完全不透明的区域，是否显示取决于它上面是否有遮挡或是否透明</li>
<li><code>VisibleRegion</code> ：可见区域，包括完全不透明无遮挡区域或半透明区域；即 <code>visibleRegion = Region - above OpaqueRegion.</code></li>
<li><code>CoveredRegion</code> ：被遮挡区域，在它之上，有不透明或半透明区域</li>
<li><code>DirtyRegion</code> ：可见部分改变区域，包括新的被遮挡区域，和新的露出区域</li>
</ul>
<p>头文件定义：</p>
<p>&#x2F;&#x2F; Layer.h<br>class Layer : public SurfaceFlingerConsumer::ContentsChangedListener {<br>public:<br>    …<br>    &#x2F;&#x2F; regions below are in window-manager space<br>    Region visibleRegion;<br>    Region coveredRegion;<br>    Region visibleNonTransparentRegion;<br>    Region surfaceDamageRegion;</p>
<pre><code>// Layer serial number.  This gives layers an explicit ordering, so we
// have a stable sort order when their layer stack and Z-order are
// the same.
int32_t sequence;
...
</code></pre>
<p>private:<br>    …<br>    &#x2F;&#x2F; constants<br>    sp<SurfaceFlingerConsumer> mSurfaceFlingerConsumer;<br>    sp<IGraphicBufferProducer> mProducer;<br>    uint32_t mTextureName;      &#x2F;&#x2F; from GLES<br>    bool mPremultipliedAlpha;<br>    String8 mName;<br>    String8 mTransactionName; &#x2F;&#x2F; A cached version of “TX - “ + mName for systraces<br>    PixelFormat mFormat;<br>    …<br>    FenceTimeline mAcquireTimeline;<br>    FenceTimeline mReleaseTimeline;<br>    …<br>    &#x2F;&#x2F; The mesh used to draw the layer in GLES composition mode<br>    mutable Mesh mMesh;<br>    &#x2F;&#x2F; The texture used to draw the layer in GLES composition mode<br>    mutable Texture mTexture;<br>    Vector<BufferItem> mQueueItems;<br>    &#x2F;&#x2F; Child list about to be committed&#x2F;used for editing.<br>    LayerVector mCurrentChildren;<br>    &#x2F;&#x2F; Child list used for rendering.<br>    LayerVector mDrawingChildren;</p>
<pre><code>wp&lt;Layer&gt; mCurrentParent;
wp&lt;Layer&gt; mDrawingParent;
</code></pre>
<p>}</p>
<p><code>SurfaceFlinger</code> 接收所有 <code>Surface</code> 作为输入，根据 <code>Z-Order</code>， 透明度，大小，位置等参数，计算出每个 <code>Surface</code> 在最终合成图像中的位置，然后交由 <code>HWComposer, OpenGL</code> 生成最终的显示 <code>Buffer</code> , 然后显示到特定的显示设备上。<br><code>Layer</code> 的合成分为两种，离线合成和在线合成：</p>
<ul>
<li>离线合成<br>  先将所有图层画到一个最终层 <code>FrameBuffer</code> 上，再将 <code>FrameBuffer</code> 送到 <code>LCD</code> 显示。由于合成 <code>FrameBuffer</code> 与送 <code>LCD</code> 显示一般是异步的（线下生成 <code>FrameBuffer</code> ，需要时线上的 <code>LCD</code> 去取），因此叫离线合成。</li>
<li>在线合成<br>  不使用 <code>FrameBuffer</code> ，在 <code>LCD</code> 需要显示某一行的像素时，用显示控制器将所有图层与该行相关的数据取出，合成一行像素送过去。只有一个图层时，又叫 <code>Overlay</code> 技术。<br>  由于省去合成 <code>FrameBuffer</code> 时读图层，写 <code>FrameBuffer</code> 的步骤，大幅降低了内存传输量，减少了功耗，但这个需要硬件支持。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-layer-composer.jpg"></p>
<h3 id="Surface-创建流程图"><a href="#Surface-创建流程图" class="headerlink" title="Surface 创建流程图"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#Surface-%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE" title="Surface 创建流程图"></a><code>Surface</code> 创建流程图</h3><p>由客户端 <code>SurfaceComposerClient</code> 发起创建流程，然后由服务端 <code>SurfaceFlinger</code> 创建对应的 <code>Layer</code> ，而 <code>Layer</code> 在被引用时会创建生产者消费者模型的 <code>BufferQueue</code> ，然后再由客户端将拿到的结果传入 <code>SurfaceControl</code> ，最后直接实例化一个 <code>Surface</code> 。</p>
<p>创建生产者消费者模型 <code>BufferQueue</code> 的关键代码：</p>
<p>&#x2F;&#x2F; Layer.cpp<br>void Layer::onFirstRef() {<br>    &#x2F;&#x2F; Creates a custom BufferQueue for SurfaceFlingerConsumer to use<br>    sp<IGraphicBufferProducer> producer;<br>    sp<IGraphicBufferConsumer> consumer;<br>    BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, true);<br>    mProducer &#x3D; new MonitoredProducer(producer, mFlinger, this);<br>    mSurfaceFlingerConsumer &#x3D;<br>        new SurfaceFlingerConsumer(consumer, mTextureName, this);<br>    mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));<br>    mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);<br>    mSurfaceFlingerConsumer-&gt;setName(mName);</p>
<pre><code>if (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123;
    mProducer-&gt;setMaxDequeuedBufferCount(2);
&#125;

const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());
updateTransformHint(hw);
</code></pre>
<p>}</p>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/606437-645921566ffd77c6.png">创建 Surface 流程，查看大图</a></p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-create-surface.png"></p>
<h3 id="VSYNC-垂直刷新-1"><a href="#VSYNC-垂直刷新-1" class="headerlink" title="VSYNC 垂直刷新"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#VSYNC-%E5%9E%82%E7%9B%B4%E5%88%B7%E6%96%B0-1" title="VSYNC 垂直刷新"></a><code>VSYNC</code> 垂直刷新</h3><p><code>Android</code> 中有 2 种 <code>VSync</code> 信号：屏幕产生的硬件 <code>VSync</code> 和由 <code>SurfaceFlinger</code> 将其转成的软件 <code>Vsync</code> 信号；软件 <code>Vsync</code> 后者经由 <code>Binder</code> 传递给 <code>Choreographer</code> 。<br><code>Vsync</code> 信号可将某些事件同步到显示设备的刷新周期。应用总是在 <code>VSYNC</code> 边界上开始绘制，而 <code>SurfaceFlinger</code> 总是在 <code>VSYNC</code> 边界上进行合成。这样可以消除卡顿，并提升图形的视觉表现。 <code>HWComposer</code> 对象创建过程，会注册一些回调方法；当硬件产生 <code>VSYNC</code> 信号时，则会回调 <code>HWC2::ComposerCallbackBridge::onVsync</code> 方法，然后逐级回调，下图是整个回调流程图：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-VsyncCallback.png"></p>
<ul>
<li>硬件 <code>Vsync</code> 信号发送过来，一路执行到 <code>DispSyncThread.updateModel</code> 方法中调用 <code>mCond.signal</code> ，唤醒 <code>DispSyncThread</code> 线程</li>
<li><code>DispSyncThread</code> 线程中执行 <code>EventThread::onVSyncEvent</code> 中调用 <code>mCondition.broadcast</code> 唤醒 <code>EventThread</code> 线程</li>
<li><code>EventThread</code> 线程中执行 <code>DisplayEventReceiver::sendEvents</code> 方法，会调用 <code>BitTube::sendObjects</code> ；在 <code>MessageQueue::setEventThread</code> 中，我们设置了 <code>BitTube</code> 事件的回调，当收到数据会触发 <code>MQ.cb_eventReceiver</code> ；根据 <code>Handler</code> 消息机制，进入 <code>SurfaceFlinger</code> 主线程</li>
<li><code>SurfaceFlinger</code> 主线程进入到 <code>MesageQueue的handleMessage</code> ，最终调用 <code>SurfaceFlinger::handleMessageRefresh</code></li>
</ul>
<h3 id="客户端通知-SurfaceFlinger-刷新"><a href="#客户端通知-SurfaceFlinger-刷新" class="headerlink" title="客户端通知 SurfaceFlinger 刷新"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E7%9F%A5-SurfaceFlinger-%E5%88%B7%E6%96%B0" title="客户端通知 SurfaceFlinger 刷新"></a>客户端通知 <code>SurfaceFlinger</code> 刷新</h3><p><code>BufferQueueProducer::queueBuffer</code> 函数中会调用 <code>listener-&gt;onFrameAvailable</code> ，而这最终会触发服务端的 <code>Layer::onFrameAvailable</code> ，从而通知 <code>SurfaceFlinger</code> 合成图像。我们先看 <code>onFrameAvailable</code> 接口的继承关系：</p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-onFrameAvailable-class-uml.png"></p>
<p>从 <code>Surface</code> 创建流程中贴出的 <code>Layer::onFirstRef</code> 代码中可以看到，在 <code>Layer</code> 中设置了 <code>mSurfaceFlingerConsumer-&gt;setContentsChangedListener</code> 监听事件，所以 <code>BufferQueueProducer::queueBuffer</code> 会触发 <code>Layer::onFrameAvailable</code> 事件，下面是完整的请求流程。<br>客户端在 <code>BufferQueue</code> 中生产完图像数据后，通知 <code>SurfaceFlinger</code> 刷新界面的流程图：</p>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/606437-4f8a5a419984488c.png">客户端通知 SurfaceFlinger 刷新，查看大图</a></p>
<p><img src="https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0113-android-graphics-display-requestNextVsync.png"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%90%8E%E7%BB%AD" title="后续"></a>后续</h2><ul>
<li><code>WMS</code></li>
<li><code>Layer</code> 合成流程</li>
<li>结合 <code>Camera</code> 熟悉图形显示中 <code>Buffer</code> 相关流程</li>
<li><code>Choreographer</code> 及掉帧分析<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd32ec35db1d">Choreographer 简析</a></li>
</ul>
</li>
<li>详述 <code>SurfaceTexture, SurfaceView, GLSurfaceView</code> 等区别</li>
<li>工具 <code>dumpsys SurfaceFlinger</code> 输出的 <code>LOG</code> 分析</li>
<li><code>screencap</code> 命令及源码分析</li>
<li><code>Systrace</code> 性能工具分析<ul>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/debug/systrace">Systrace 官网</a></li>
</ul>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/graphics">Android 图形显示 - 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ear5cm/article/details/45458683">Android 中 native_handle private_handle_t 的关系</a></li>
<li><strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/f92447ae8445">夕阳风 - 图形显示系列文章</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://windrunnerlihuan.com/2017/04/27/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%8C-SurfaceFlinger%E6%A6%82%E8%BF%B0/">SurfaceFlinger 系列</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaizu/article/details/51882768">理解 VSYNC</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yaozhongxiao/archive/2014/07/14/3842908.html">dp, dpi, px, density 的关系</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2017/02/18/surface_flinger_2/">gityuan: SurfaceFlinger 相关</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/innost/article/details/47208337">阿拉神农：深入理解 Surface 系统</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/freekiteyu/article/details/79483406">图解 Surface, SurfaceFlinger 关系</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/grafika">Google Grafika</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013928208/article/details/82999075">图形引擎的核心 - BufferQueue</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xisuzun7960/article/details/81212721">surfaceflinger 框架 - 流程图大全</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/armwind/article/details/73436532">BufferQueue 介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/39698317/">GraphicBuffer 同步机制 - Fence</a></li>
</ul>
<p>全文完</p>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread">简悦 SimpRead</a> 优化，用以提升阅读体验</p>
<p>使用了 全新的简悦词法分析引擎 beta，<a target="_blank" rel="noopener" href="http://ksria.com/simpread/docs/#/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E">点击查看</a>详细说明</p>
<p><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-0">概念</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-1">EGL</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-2">Surface 和 SurfaceFlinger</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-3">WMS: WindowManagerServices</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-4">FrameBuffer</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-5">Gralloc</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-6">HWC</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-7">VSYNC 垂直刷新</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-8">60Hz 和 16 ms</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-9">BufferQueue</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-10">数据流</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-11">组件小结</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-12">Buffer&#x2F;Window 体系</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-13">代码速查表</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-14">native_handle&#x2F;buffer_handle_t</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-15">private_handle_t</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-16">ANativeWindowBuffer</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-17">ANativeWindow</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-18">ANativeObjectBase 模板</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-19">GraphicBuffer</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-20">Surface</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-21">小结</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-22">libui 库</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-23">代码目录结构</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-24">GraphicBufferAllocator&#x2F;GraphicBufferMapper</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-25">GraphicBuffer</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-26">Fence 机制</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-27">DisplayInfo 显示信息</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-28">libgui 库</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-29">代码目录结构</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-30">IGraphicBufferProducer&#x2F;IProducerListener 生产者</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-31">IGraphicBufferConsumer&#x2F;IConsumerListener 消费者</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-32">BufferItem</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-33">BufferSlot</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-34">BufferQueueCore</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-35">BufferQueueProducer&#x2F;BufferQueueConsumer 生产者 &#x2F; 消费者实现类</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-36">BufferQueue 模型</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-37">Surface</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-38">ISurfaceComposer&#x2F;ISurfaceComposerClient</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-39">SurfaceControl</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-40">IDisplayEventConnection 显示连接</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-41">小结</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-42">SurfaceFlinger</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-43">代码速查表</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-44">surfaceflinger 进程</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-45">初始化流程</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-46">DisplayDevice 显示设备</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-47">Layer 层</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-48">Surface 创建流程图</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-49">VSYNC 垂直刷新</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-50">客户端通知 SurfaceFlinger 刷新</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-51">后续</a><a target="_blank" rel="noopener" href="https://redspider110.github.io/2019/04/17/0113-android-graphics-display/#sr-toc-52">参考文档</a></p>

      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2024/01/10/OpenGL/OpenGL/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">OpenGL</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://github.com/BlairRenaissance/ImageHost/blob/main/WeCom20240109-193846@2x.png?raw=true" class="soft-size--round soft-style--box" alt="Renaissance">
    
    
      <h2>Renaissance</h2>
    
    
      <p>谁的身影 尽逐重楼</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>3</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        3
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        3
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>STUDY模式！</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/category/OpenGL/">
            OpenGL (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/category/Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/">
            Android图形显示 (0)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/category/Android/">
            Android (2)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tag/Android/" style="font-size: 20px;" class="tags-cloud-10">Android</a> <a href="/tag/Android%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA/" style="font-size: 10px;" class="tags-cloud-0">Android图形显示</a> <a href="/tag/OpenGL/" style="font-size: 15px;" class="tags-cloud-5">OpenGL</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/BlairRenaissance" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2024 <a href="/" target="_blank">Blair Ren</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->


<!-- copy button  -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>

<!-- https://clipboardjs.com/ -->









  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
